{
  "api": {
    "base_url": "https://api.first.org/data/v1",
    "endpoints": [
      {
        "description": "Query EPSS scores for CVEs with flexible filtering",
        "headers": {
          "Accept": "application/json"
        },
        "method": "GET",
        "parameters": [
          {
            "description": "Single CVE or comma-separated list",
            "example": "CVE-2021-44228,CVE-2021-34527",
            "name": "cve",
            "required": false,
            "type": "string"
          },
          {
            "description": "Date for historical scores (YYYY-MM-DD)",
            "example": "2024-01-15",
            "name": "date",
            "required": false,
            "type": "string"
          },
          {
            "description": "EPSS score greater than value",
            "example": "0.5",
            "name": "epss-gt",
            "required": false,
            "type": "number"
          },
          {
            "description": "EPSS score less than value",
            "example": "0.9",
            "name": "epss-lt",
            "required": false,
            "type": "number"
          },
          {
            "description": "Percentile greater than value",
            "example": "0.9",
            "name": "percentile-gt",
            "required": false,
            "type": "number"
          },
          {
            "description": "Percentile less than value",
            "example": "0.95",
            "name": "percentile-lt",
            "required": false,
            "type": "number"
          },
          {
            "description": "Maximum number of results (default 100, max 10000)",
            "example": "1000",
            "name": "limit",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Pagination offset",
            "example": "0",
            "name": "offset",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Sort order for results",
            "example": "!epss",
            "name": "order",
            "required": false,
            "type": "string"
          }
        ],
        "path": "/epss",
        "rate_limit": {
          "notes": "1000 requests per day without API key. Consider bulk download for large datasets.",
          "requests_per_day": 1000
        },
        "response_format": {
          "example": {
            "data": [
              {
                "cve": "CVE-2021-44228",
                "date": "2024-01-15",
                "epss": "0.97564",
                "model_version": "v2023.03.01",
                "percentile": "0.99996"
              }
            ],
            "status": "OK",
            "status-code": 200,
            "total": 1,
            "version": "1.0"
          },
          "type": "JSON"
        }
      }
    ],
    "type": "REST"
  },
  "authentication": {
    "documentation": "https://www.first.org/epss/api",
    "example_implementation": {
      "curl": "curl 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228'",
      "javascript": "fetch('https://api.first.org/data/v1/epss?cve=CVE-2021-44228')",
      "python": "response = requests.get('https://api.first.org/data/v1/epss?cve=CVE-2021-44228')"
    },
    "required": false,
    "setup_instructions": [
      "No authentication required for basic usage",
      "Rate limit of 1000 requests per day without API key",
      "For high-volume usage, download bulk CSV files instead"
    ],
    "type": "none"
  },
  "authority": "official",
  "bulk_download": {
    "current_scores": {
      "description": "Complete dataset of current EPSS scores for all CVEs",
      "format": "CSV (gzip compressed)",
      "update_frequency": "Daily",
      "url": "https://epss.cyentia.com/epss_scores-current.csv.gz"
    },
    "historical_scores": {
      "description": "Historical EPSS scores for specific dates",
      "example": "https://epss.cyentia.com/epss_scores-2024-01-15.csv.gz",
      "format": "CSV (gzip compressed)",
      "url_pattern": "https://epss.cyentia.com/epss_scores-YYYY-MM-DD.csv.gz"
    }
  },
  "category": "vulnerability",
  "coverage": 95,
  "data_coverage": {
    "completeness": "200,000+ CVEs with continuous expansion",
    "data_types": [
      "CVE",
      "Exploitation Probability",
      "Risk Scoring"
    ],
    "geographical": "global",
    "temporal": {
      "historical_data": "2021-present",
      "latency": "New CVEs scored within 24-48 hours of publication",
      "update_frequency": "daily"
    }
  },
  "data_format": {
    "compression": "gzip (for bulk downloads)",
    "encoding": "UTF-8",
    "field_descriptions": {
      "cve": "CVE identifier",
      "date": "Date of the score calculation",
      "epss": "Exploitation probability score (0.0-1.0)",
      "model_version": "Version of the EPSS model used",
      "percentile": "Percentile ranking among all scored CVEs (0.0-1.0)"
    },
    "primary_format": "JSON",
    "schemas": {
      "documentation": "https://www.first.org/epss/model"
    }
  },
  "description": "The Exploit Prediction Scoring System (EPSS) is a data-driven effort for estimating the likelihood (probability) that a software vulnerability will be exploited in the wild. EPSS provides a probabilistic score between 0 and 1 (0-100%) representing the likelihood that a vulnerability will be exploited in the next 30 days, built using machine learning models trained on real-world exploit data.",
  "documentation": "https://www.first.org/epss/api",
  "format": "json",
  "id": "epss",
  "integration_examples": {
    "curl": {
      "basic_fetch": "# Get EPSS score for a specific CVE\ncurl 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228'",
      "bulk_download": "# Download complete EPSS dataset\ncurl -O https://epss.cyentia.com/epss_scores-current.csv.gz\ngunzip epss_scores-current.csv.gz",
      "date_specific": "# Get historical scores for specific date\ncurl 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228&date=2023-12-01'",
      "high_scores": "# Get all CVEs with EPSS > 0.9\ncurl 'https://api.first.org/data/v1/epss?epss-gt=0.9&limit=100&order=!epss'",
      "multiple_cves": "# Get scores for multiple CVEs\ncurl 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228,CVE-2021-34527,CVE-2023-20198'",
      "parse_bulk": "# Parse bulk CSV for high scores\nzcat epss_scores-current.csv.gz | awk -F, '$2 > 0.9' | head -20",
      "pretty_print": "# Get score with formatted output\ncurl -s 'https://api.first.org/data/v1/epss?cve=CVE-2021-44228' | jq '.'",
      "top_percentile": "# Get CVEs in top 1% by percentile\ncurl 'https://api.first.org/data/v1/epss?percentile-gt=0.99&limit=50'"
    },
    "go": {
      "basic_fetch": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n    \"strconv\"\n)\n\ntype EPSSResponse struct {\n    Status     string     `json:\"status\"`\n    StatusCode int        `json:\"status-code\"`\n    Version    string     `json:\"version\"`\n    Total      int        `json:\"total\"`\n    Data       []EPSSData `json:\"data\"`\n}\n\ntype EPSSData struct {\n    CVE          string `json:\"cve\"`\n    EPSS         string `json:\"epss\"`\n    Percentile   string `json:\"percentile\"`\n    Date         string `json:\"date\"`\n    ModelVersion string `json:\"model_version\"`\n}\n\nfunc getEPSSScore(cveID string) (*EPSSData, error) {\n    baseURL := \"https://api.first.org/data/v1/epss\"\n    params := url.Values{}\n    params.Add(\"cve\", cveID)\n    \n    fullURL := fmt.Sprintf(\"%s?%s\", baseURL, params.Encode())\n    \n    resp, err := http.Get(fullURL)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to fetch EPSS data: %w\", err)\n    }\n    defer resp.Body.Close()\n    \n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read response: %w\", err)\n    }\n    \n    var epssResp EPSSResponse\n    if err := json.Unmarshal(body, &epssResp); err != nil {\n        return nil, fmt.Errorf(\"failed to parse JSON: %w\", err)\n    }\n    \n    if epssResp.Status == \"OK\" && len(epssResp.Data) > 0 {\n        return &epssResp.Data[0], nil\n    }\n    \n    return nil, fmt.Errorf(\"no EPSS data found for %s\", cveID)\n}\n\nfunc classifyRisk(epssScore float64) string {\n    if epssScore >= 0.9 {\n        return \"CRITICAL\"\n    } else if epssScore >= 0.7 {\n        return \"HIGH\"\n    } else if epssScore >= 0.3 {\n        return \"MEDIUM\"\n    } else if epssScore >= 0.1 {\n        return \"LOW\"\n    }\n    return \"MINIMAL\"\n}\n\nfunc main() {\n    // Example CVEs to check\n    cves := []string{\n        \"CVE-2021-44228\",\n        \"CVE-2023-20198\",\n        \"CVE-2020-1472\",\n    }\n    \n    fmt.Println(\"EPSS Vulnerability Assessment\")\n    fmt.Println(\"==============================\")\n    \n    for _, cve := range cves {\n        data, err := getEPSSScore(cve)\n        if err != nil {\n            fmt.Printf(\"%s: Error - %v\\n\", cve, err)\n            continue\n        }\n        \n        // Convert string scores to float\n        epssScore, _ := strconv.ParseFloat(data.EPSS, 64)\n        percentile, _ := strconv.ParseFloat(data.Percentile, 64)\n        \n        risk := classifyRisk(epssScore)\n        \n        fmt.Printf(\"%s:\\n\", cve)\n        fmt.Printf(\"  Risk Level: %s\\n\", risk)\n        fmt.Printf(\"  EPSS Score: %.2f%%\\n\", epssScore*100)\n        fmt.Printf(\"  Percentile: %.2f%%\\n\", percentile*100)\n        fmt.Printf(\"  Date: %s\\n\\n\", data.Date)\n    }\n}"
    },
    "javascript": {
      "basic_fetch": "// Get EPSS score for a CVE\nconst getEPSSScore = async (cveId) => {\n  const url = `https://api.first.org/data/v1/epss?cve=${cveId}`;\n  \n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    \n    if (data.status === 'OK' && data.data.length > 0) {\n      const result = data.data[0];\n      return {\n        cve: result.cve,\n        score: parseFloat(result.epss),\n        percentile: parseFloat(result.percentile),\n        date: result.date\n      };\n    }\n    return null;\n  } catch (error) {\n    console.error('Error fetching EPSS score:', error);\n    throw error;\n  }\n};\n\n// Usage\ngetEPSSScore('CVE-2021-44228').then(score => {\n  if (score) {\n    console.log(`${score.cve}: ${(score.score * 100).toFixed(2)}% exploitation probability`);\n    console.log(`Percentile: ${(score.percentile * 100).toFixed(2)}%`);\n  }\n});",
      "dashboard_widget": "// EPSS Dashboard Widget\nclass EPSSDashboard {\n  constructor(containerId) {\n    this.container = document.getElementById(containerId);\n    this.assessor = new EPSSRiskAssessor();\n  }\n  \n  async renderTopThreats(limit = 10) {\n    const threats = await this.assessor.getHighRiskCVEs(0.9, limit);\n    \n    const html = `\n      <div class=\"epss-dashboard\">\n        <h3>Top Exploitation Risks (EPSS)</h3>\n        <div class=\"threat-list\">\n          ${threats.map(threat => `\n            <div class=\"threat-item\" style=\"border-left: 4px solid ${threat.risk.color}\">\n              <div class=\"cve-id\">${threat.cve}</div>\n              <div class=\"score-bar\">\n                <div class=\"score-fill\" style=\"width: ${threat.score * 100}%; background: ${threat.risk.color}\"></div>\n              </div>\n              <div class=\"score-text\">${(threat.score * 100).toFixed(1)}%</div>\n              <div class=\"percentile\">Top ${((1 - threat.percentile) * 100).toFixed(2)}%</div>\n            </div>\n          `).join('')}\n        </div>\n      </div>\n    `;\n    \n    this.container.innerHTML = html;\n  }\n  \n  async renderAssessment(cveList) {\n    const assessment = await this.assessor.assessVulnerabilities(cveList);\n    \n    const summary = {\n      total: cveList.length,\n      critical: assessment.critical.length,\n      high: assessment.high.length,\n      medium: assessment.medium.length,\n      low: assessment.low.length,\n      minimal: assessment.minimal.length\n    };\n    \n    const html = `\n      <div class=\"epss-assessment\">\n        <h3>EPSS Risk Assessment</h3>\n        \n        <div class=\"summary-cards\">\n          <div class=\"card critical\">\n            <div class=\"count\">${summary.critical}</div>\n            <div class=\"label\">Critical</div>\n          </div>\n          <div class=\"card high\">\n            <div class=\"count\">${summary.high}</div>\n            <div class=\"label\">High</div>\n          </div>\n          <div class=\"card medium\">\n            <div class=\"count\">${summary.medium}</div>\n            <div class=\"label\">Medium</div>\n          </div>\n          <div class=\"card low\">\n            <div class=\"count\">${summary.low}</div>\n            <div class=\"label\">Low</div>\n          </div>\n        </div>\n        \n        ${assessment.critical.length > 0 ? `\n          <div class=\"critical-section\">\n            <h4>Critical Risk CVEs (Immediate Action Required)</h4>\n            <ul>\n              ${assessment.critical.map(v => `\n                <li>${v.cve}: ${(v.score * 100).toFixed(2)}% exploitation probability</li>\n              `).join('')}\n            </ul>\n          </div>\n        ` : ''}\n      </div>\n    `;\n    \n    this.container.innerHTML = html;\n  }\n}\n\n// Initialize dashboard\nif (typeof document !== 'undefined') {\n  const dashboard = new EPSSDashboard('epss-container');\n  dashboard.renderTopThreats(10);\n}",
      "risk_assessor": "// EPSS Risk Assessment Tool\nclass EPSSRiskAssessor {\n  constructor() {\n    this.apiUrl = 'https://api.first.org/data/v1/epss';\n    this.cache = new Map();\n    this.cacheExpiry = 3600000; // 1 hour\n  }\n  \n  async getScore(cveId) {\n    // Check cache\n    const cached = this.cache.get(cveId);\n    if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {\n      return cached.data;\n    }\n    \n    // Fetch from API\n    const response = await fetch(`${this.apiUrl}?cve=${cveId}`);\n    const data = await response.json();\n    \n    if (data.status === 'OK' && data.data.length > 0) {\n      const result = {\n        cve: data.data[0].cve,\n        score: parseFloat(data.data[0].epss),\n        percentile: parseFloat(data.data[0].percentile),\n        date: data.data[0].date\n      };\n      \n      // Cache result\n      this.cache.set(cveId, {\n        data: result,\n        timestamp: Date.now()\n      });\n      \n      return result;\n    }\n    return null;\n  }\n  \n  async getBatchScores(cveList) {\n    // API supports comma-separated CVEs\n    const cveString = cveList.join(',');\n    const response = await fetch(`${this.apiUrl}?cve=${cveString}`);\n    const data = await response.json();\n    \n    const results = {};\n    if (data.status === 'OK') {\n      data.data.forEach(item => {\n        results[item.cve] = {\n          score: parseFloat(item.epss),\n          percentile: parseFloat(item.percentile),\n          date: item.date\n        };\n      });\n    }\n    \n    return results;\n  }\n  \n  classifyRisk(epssScore) {\n    if (epssScore >= 0.9) return { level: 'CRITICAL', color: '#ff0000', action: 'Patch immediately' };\n    if (epssScore >= 0.7) return { level: 'HIGH', color: '#ff6600', action: 'Patch within 7 days' };\n    if (epssScore >= 0.3) return { level: 'MEDIUM', color: '#ffaa00', action: 'Patch within 30 days' };\n    if (epssScore >= 0.1) return { level: 'LOW', color: '#ffff00', action: 'Patch within 90 days' };\n    return { level: 'MINIMAL', color: '#00ff00', action: 'Monitor' };\n  }\n  \n  async assessVulnerabilities(cveList) {\n    const scores = await this.getBatchScores(cveList);\n    const assessment = {\n      critical: [],\n      high: [],\n      medium: [],\n      low: [],\n      minimal: [],\n      noData: []\n    };\n    \n    cveList.forEach(cve => {\n      if (scores[cve]) {\n        const risk = this.classifyRisk(scores[cve].score);\n        const entry = {\n          cve,\n          ...scores[cve],\n          risk: risk.level,\n          action: risk.action\n        };\n        \n        switch(risk.level) {\n          case 'CRITICAL': assessment.critical.push(entry); break;\n          case 'HIGH': assessment.high.push(entry); break;\n          case 'MEDIUM': assessment.medium.push(entry); break;\n          case 'LOW': assessment.low.push(entry); break;\n          case 'MINIMAL': assessment.minimal.push(entry); break;\n        }\n      } else {\n        assessment.noData.push(cve);\n      }\n    });\n    \n    // Sort each category by score\n    ['critical', 'high', 'medium', 'low', 'minimal'].forEach(level => {\n      assessment[level].sort((a, b) => b.score - a.score);\n    });\n    \n    return assessment;\n  }\n  \n  async getHighRiskCVEs(minScore = 0.7, limit = 100) {\n    const params = new URLSearchParams({\n      'epss-gt': minScore,\n      'limit': limit,\n      'order': '!epss'\n    });\n    \n    const response = await fetch(`${this.apiUrl}?${params}`);\n    const data = await response.json();\n    \n    if (data.status === 'OK') {\n      return data.data.map(item => ({\n        cve: item.cve,\n        score: parseFloat(item.epss),\n        percentile: parseFloat(item.percentile),\n        risk: this.classifyRisk(parseFloat(item.epss))\n      }));\n    }\n    return [];\n  }\n}\n\n// Usage\nconst assessor = new EPSSRiskAssessor();\n\n// Assess a list of CVEs\nconst cvesToAssess = [\n  'CVE-2021-44228',\n  'CVE-2023-20198',\n  'CVE-2020-1472',\n  'CVE-2019-11510',\n  'CVE-2018-13379'\n];\n\nassessor.assessVulnerabilities(cvesToAssess).then(assessment => {\n  console.log('Vulnerability Assessment Results:');\n  console.log('================================');\n  \n  if (assessment.critical.length > 0) {\n    console.log('\\nCRITICAL RISK:');\n    assessment.critical.forEach(v => {\n      console.log(`  ${v.cve}: ${(v.score * 100).toFixed(2)}% - ${v.action}`);\n    });\n  }\n  \n  if (assessment.high.length > 0) {\n    console.log('\\nHIGH RISK:');\n    assessment.high.forEach(v => {\n      console.log(`  ${v.cve}: ${(v.score * 100).toFixed(2)}% - ${v.action}`);\n    });\n  }\n  \n  console.log(`\\nTotal: ${cvesToAssess.length} CVEs assessed`);\n  console.log(`Critical: ${assessment.critical.length}`);\n  console.log(`High: ${assessment.high.length}`);\n  console.log(`Medium: ${assessment.medium.length}`);\n  console.log(`Low: ${assessment.low.length}`);\n  console.log(`Minimal: ${assessment.minimal.length}`);\n});"
    },
    "python": {
      "basic_fetch": "import requests\nimport json\n\n# Get EPSS score for a specific CVE\ncve_id = 'CVE-2021-44228'\nurl = f'https://api.first.org/data/v1/epss?cve={cve_id}'\n\nresponse = requests.get(url)\ndata = response.json()\n\nif data['status'] == 'OK' and data['data']:\n    result = data['data'][0]\n    print(f\"CVE: {result['cve']}\")\n    print(f\"EPSS Score: {float(result['epss']):.2%}\")\n    print(f\"Percentile: {float(result['percentile']):.2%}\")\n    print(f\"Model Version: {result.get('model_version', 'N/A')}\")\nelse:\n    print(f\"No EPSS data found for {cve_id}\")",
      "batch_lookup": "import requests\nfrom typing import List, Dict\n\ndef get_epss_scores(cve_list: List[str]) -> Dict[str, Dict]:\n    \"\"\"Get EPSS scores for multiple CVEs\"\"\"\n    # API supports comma-separated CVEs\n    cve_string = ','.join(cve_list)\n    url = f'https://api.first.org/data/v1/epss?cve={cve_string}'\n    \n    response = requests.get(url)\n    data = response.json()\n    \n    results = {}\n    if data['status'] == 'OK':\n        for item in data['data']:\n            results[item['cve']] = {\n                'score': float(item['epss']),\n                'percentile': float(item['percentile']),\n                'date': item['date']\n            }\n    \n    return results\n\n# Example usage\ncves = ['CVE-2021-44228', 'CVE-2021-34527', 'CVE-2023-20198']\nscores = get_epss_scores(cves)\n\nfor cve, data in scores.items():\n    print(f\"{cve}: Score={data['score']:.2%}, Percentile={data['percentile']:.2%}\")",
      "bulk_download_parser": "import pandas as pd\nimport gzip\nimport requests\nfrom io import BytesIO\n\ndef download_epss_bulk():\n    \"\"\"Download and parse bulk EPSS data\"\"\"\n    url = 'https://epss.cyentia.com/epss_scores-current.csv.gz'\n    \n    # Download compressed file\n    response = requests.get(url)\n    \n    # Decompress and read CSV\n    with gzip.open(BytesIO(response.content), 'rt') as f:\n        df = pd.read_csv(f, comment='#')\n    \n    # Convert to proper data types\n    df['epss'] = df['epss'].astype(float)\n    df['percentile'] = df['percentile'].astype(float)\n    \n    return df\n\n# Download and analyze\nprint(\"Downloading EPSS bulk data...\")\nepss_df = download_epss_bulk()\n\nprint(f\"Total CVEs: {len(epss_df)}\")\nprint(f\"Average EPSS Score: {epss_df['epss'].mean():.4f}\")\nprint(f\"Median EPSS Score: {epss_df['epss'].median():.4f}\")\n\n# High risk CVEs\nhigh_risk = epss_df[epss_df['epss'] > 0.9]\nprint(f\"\\nHigh Risk CVEs (EPSS > 0.9): {len(high_risk)}\")\nprint(\"\\nTop 10 by EPSS Score:\")\nfor _, row in high_risk.nlargest(10, 'epss').iterrows():\n    print(f\"  {row['cve']}: {row['epss']:.4f} ({row['percentile']:.4f} percentile)\")",
      "full_example": "#!/usr/bin/env python3\n\"\"\"\nEPSS Integration Client - Complete working example\n\"\"\"\n\nimport requests\nimport json\nimport pandas as pd\nimport gzip\nfrom io import BytesIO\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nimport sqlite3\n\nclass EPSSClient:\n    def __init__(self, cache_db: str = 'epss_cache.db'):\n        self.api_url = 'https://api.first.org/data/v1/epss'\n        self.bulk_url = 'https://epss.cyentia.com/epss_scores-current.csv.gz'\n        self.cache_db = cache_db\n        self._init_cache()\n    \n    def _init_cache(self):\n        \"\"\"Initialize SQLite cache database\"\"\"\n        conn = sqlite3.connect(self.cache_db)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS epss_scores (\n                cve TEXT PRIMARY KEY,\n                epss REAL,\n                percentile REAL,\n                date TEXT,\n                last_updated TIMESTAMP\n            )\n        ''')\n        \n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS thresholds (\n                name TEXT PRIMARY KEY,\n                min_score REAL,\n                max_score REAL,\n                action TEXT\n            )\n        ''')\n        \n        # Insert default thresholds\n        default_thresholds = [\n            ('CRITICAL', 0.9, 1.0, 'Patch within 24 hours'),\n            ('HIGH', 0.7, 0.9, 'Patch within 7 days'),\n            ('MEDIUM', 0.3, 0.7, 'Patch within 30 days'),\n            ('LOW', 0.1, 0.3, 'Patch within 90 days'),\n            ('MINIMAL', 0.0, 0.1, 'Monitor and assess')\n        ]\n        \n        for threshold in default_thresholds:\n            cursor.execute('''\n                INSERT OR IGNORE INTO thresholds VALUES (?, ?, ?, ?)\n            ''', threshold)\n        \n        conn.commit()\n        conn.close()\n    \n    def get_score(self, cve: str, use_cache: bool = True) -> Optional[Dict]:\n        \"\"\"Get EPSS score for a single CVE\"\"\"\n        if use_cache:\n            cached = self._get_cached_score(cve)\n            if cached:\n                return cached\n        \n        response = requests.get(f\"{self.api_url}?cve={cve}\")\n        data = response.json()\n        \n        if data['status'] == 'OK' and data['data']:\n            result = data['data'][0]\n            score_data = {\n                'cve': result['cve'],\n                'epss': float(result['epss']),\n                'percentile': float(result['percentile']),\n                'date': result['date']\n            }\n            \n            # Cache the result\n            self._cache_score(score_data)\n            return score_data\n        \n        return None\n    \n    def get_scores_batch(self, cve_list: List[str]) -> Dict[str, Dict]:\n        \"\"\"Get EPSS scores for multiple CVEs\"\"\"\n        # Check cache first\n        results = {}\n        uncached = []\n        \n        for cve in cve_list:\n            cached = self._get_cached_score(cve)\n            if cached:\n                results[cve] = cached\n            else:\n                uncached.append(cve)\n        \n        # Fetch uncached CVEs\n        if uncached:\n            # API supports up to 100 CVEs per request\n            for i in range(0, len(uncached), 100):\n                batch = uncached[i:i+100]\n                cve_string = ','.join(batch)\n                \n                response = requests.get(f\"{self.api_url}?cve={cve_string}\")\n                data = response.json()\n                \n                if data['status'] == 'OK':\n                    for item in data['data']:\n                        score_data = {\n                            'cve': item['cve'],\n                            'epss': float(item['epss']),\n                            'percentile': float(item['percentile']),\n                            'date': item['date']\n                        }\n                        results[item['cve']] = score_data\n                        self._cache_score(score_data)\n        \n        return results\n    \n    def _get_cached_score(self, cve: str) -> Optional[Dict]:\n        \"\"\"Get score from cache if fresh\"\"\"\n        conn = sqlite3.connect(self.cache_db)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            SELECT epss, percentile, date, last_updated \n            FROM epss_scores WHERE cve = ?\n        ''', (cve,))\n        \n        result = cursor.fetchone()\n        conn.close()\n        \n        if result:\n            last_updated = datetime.fromisoformat(result[3])\n            if datetime.now() - last_updated < timedelta(hours=24):\n                return {\n                    'cve': cve,\n                    'epss': result[0],\n                    'percentile': result[1],\n                    'date': result[2]\n                }\n        \n        return None\n    \n    def _cache_score(self, score_data: Dict):\n        \"\"\"Cache score in database\"\"\"\n        conn = sqlite3.connect(self.cache_db)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            INSERT OR REPLACE INTO epss_scores VALUES (?, ?, ?, ?, ?)\n        ''', (\n            score_data['cve'],\n            score_data['epss'],\n            score_data['percentile'],\n            score_data['date'],\n            datetime.now().isoformat()\n        ))\n        \n        conn.commit()\n        conn.close()\n    \n    def download_bulk_scores(self) -> pd.DataFrame:\n        \"\"\"Download and parse bulk EPSS data\"\"\"\n        print(\"Downloading bulk EPSS data...\")\n        response = requests.get(self.bulk_url)\n        \n        with gzip.open(BytesIO(response.content), 'rt') as f:\n            df = pd.read_csv(f, comment='#')\n        \n        df['epss'] = df['epss'].astype(float)\n        df['percentile'] = df['percentile'].astype(float)\n        \n        print(f\"Downloaded {len(df)} CVE scores\")\n        return df\n    \n    def get_high_risk_cves(self, min_score: float = 0.7, \n                           limit: int = 100) -> List[Dict]:\n        \"\"\"Get CVEs with high exploitation probability\"\"\"\n        params = {\n            'epss-gt': min_score,\n            'limit': limit,\n            'order': '!epss'\n        }\n        \n        response = requests.get(self.api_url, params=params)\n        data = response.json()\n        \n        high_risk = []\n        if data['status'] == 'OK':\n            for item in data['data']:\n                high_risk.append({\n                    'cve': item['cve'],\n                    'epss': float(item['epss']),\n                    'percentile': float(item['percentile']),\n                    'date': item['date']\n                })\n        \n        return high_risk\n    \n    def classify_risk(self, epss_score: float) -> str:\n        \"\"\"Classify risk level based on EPSS score\"\"\"\n        conn = sqlite3.connect(self.cache_db)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            SELECT name, action FROM thresholds \n            WHERE ? >= min_score AND ? < max_score\n        ''', (epss_score, epss_score))\n        \n        result = cursor.fetchone()\n        conn.close()\n        \n        if result:\n            return result[0]\n        return 'UNKNOWN'\n    \n    def generate_report(self, cve_list: List[str]) -> str:\n        \"\"\"Generate EPSS assessment report\"\"\"\n        scores = self.get_scores_batch(cve_list)\n        \n        # Categorize by risk level\n        risk_categories = {\n            'CRITICAL': [],\n            'HIGH': [],\n            'MEDIUM': [],\n            'LOW': [],\n            'MINIMAL': []\n        }\n        \n        for cve, data in scores.items():\n            risk_level = self.classify_risk(data['epss'])\n            risk_categories[risk_level].append((cve, data))\n        \n        # Generate report\n        report = f\"\"\"\nEPSS Vulnerability Assessment Report\n{'=' * 50}\nGenerated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\nTotal CVEs Assessed: {len(cve_list)}\nCVEs with EPSS Data: {len(scores)}\n\nRISK DISTRIBUTION\n{'-' * 20}\n\"\"\"\n        \n        for risk_level in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'MINIMAL']:\n            cves = risk_categories[risk_level]\n            report += f\"{risk_level}: {len(cves)} CVEs\\n\"\n        \n        # Detail critical and high risk\n        report += f\"\\nCRITICAL RISK CVEs (EPSS >= 0.9)\\n{'-' * 35}\\n\"\n        for cve, data in sorted(risk_categories['CRITICAL'], \n                                key=lambda x: x[1]['epss'], reverse=True):\n            report += f\"{cve}: {data['epss']:.2%} (Top {(1-data['percentile'])*100:.2f}%)\\n\"\n        \n        if risk_categories['HIGH']:\n            report += f\"\\nHIGH RISK CVEs (EPSS 0.7-0.9)\\n{'-' * 30}\\n\"\n            for cve, data in sorted(risk_categories['HIGH'][:10], \n                                   key=lambda x: x[1]['epss'], reverse=True):\n                report += f\"{cve}: {data['epss']:.2%}\\n\"\n        \n        # Statistics\n        all_scores = [data['epss'] for data in scores.values()]\n        if all_scores:\n            report += f\"\\nSTATISTICS\\n{'-' * 15}\\n\"\n            report += f\"Average EPSS: {sum(all_scores)/len(all_scores):.4f}\\n\"\n            report += f\"Max EPSS: {max(all_scores):.4f}\\n\"\n            report += f\"Min EPSS: {min(all_scores):.4f}\\n\"\n        \n        return report\n\n# Example usage\nif __name__ == '__main__':\n    client = EPSSClient()\n    \n    # Single CVE lookup\n    print(\"Single CVE Lookup:\")\n    score = client.get_score('CVE-2021-44228')\n    if score:\n        print(f\"  {score['cve']}: EPSS={score['epss']:.2%}, \"\n              f\"Percentile={score['percentile']:.2%}\")\n    \n    # Batch lookup\n    print(\"\\nBatch Lookup:\")\n    cves = ['CVE-2021-44228', 'CVE-2023-20198', 'CVE-2020-1472']\n    scores = client.get_scores_batch(cves)\n    for cve, data in scores.items():\n        risk = client.classify_risk(data['epss'])\n        print(f\"  {cve}: {risk} (EPSS={data['epss']:.2%})\")\n    \n    # Get current high-risk CVEs\n    print(\"\\nCurrent High-Risk CVEs:\")\n    high_risk = client.get_high_risk_cves(0.95, 5)\n    for cve_data in high_risk:\n        print(f\"  {cve_data['cve']}: {cve_data['epss']:.2%}\")\n    \n    # Generate report for a list of CVEs\n    test_cves = [\n        'CVE-2021-44228', 'CVE-2023-20198', 'CVE-2020-1472',\n        'CVE-2019-11510', 'CVE-2018-13379', 'CVE-2017-11882'\n    ]\n    \n    report = client.generate_report(test_cves)\n    print(\"\\n\" + report)",
      "high_risk_filter": "import requests\n\ndef get_high_risk_cves(min_score: float = 0.7, limit: int = 100):\n    \"\"\"Get CVEs with high exploitation probability\"\"\"\n    url = 'https://api.first.org/data/v1/epss'\n    params = {\n        'epss-gt': min_score,\n        'limit': limit,\n        'order': '!epss'  # Sort by EPSS score descending\n    }\n    \n    response = requests.get(url, params=params)\n    data = response.json()\n    \n    high_risk = []\n    if data['status'] == 'OK':\n        for item in data['data']:\n            high_risk.append({\n                'cve': item['cve'],\n                'score': float(item['epss']),\n                'percentile': float(item['percentile'])\n            })\n    \n    return high_risk\n\n# Get top high-risk CVEs\nhigh_risk_cves = get_high_risk_cves(0.9, 50)\nprint(f\"Found {len(high_risk_cves)} high-risk CVEs (EPSS > 0.9):\")\n\nfor cve in high_risk_cves[:10]:\n    print(f\"  {cve['cve']}: {cve['score']:.2%} (Top {(1-cve['percentile'])*100:.2f}%)\")",
      "risk_prioritization": "import requests\nfrom typing import List, Dict, Tuple\n\nclass EPSSPrioritizer:\n    def __init__(self):\n        self.api_url = 'https://api.first.org/data/v1/epss'\n    \n    def get_scores(self, cve_list: List[str]) -> Dict[str, float]:\n        \"\"\"Get EPSS scores for a list of CVEs\"\"\"\n        cve_string = ','.join(cve_list)\n        response = requests.get(f\"{self.api_url}?cve={cve_string}\")\n        data = response.json()\n        \n        scores = {}\n        if data['status'] == 'OK':\n            for item in data['data']:\n                scores[item['cve']] = float(item['epss'])\n        \n        return scores\n    \n    def prioritize(self, cve_list: List[str], \n                  cvss_scores: Dict[str, float] = None) -> List[Tuple[str, str, float]]:\n        \"\"\"Prioritize CVEs based on EPSS and optionally CVSS\"\"\"\n        epss_scores = self.get_scores(cve_list)\n        \n        priorities = []\n        for cve in cve_list:\n            epss = epss_scores.get(cve, 0)\n            \n            # Determine priority level\n            if epss >= 0.9:\n                priority = 'CRITICAL'\n                score = 100\n            elif epss >= 0.7:\n                priority = 'HIGH'\n                score = 80\n            elif epss >= 0.3:\n                priority = 'MEDIUM'\n                score = 50\n            elif epss >= 0.1:\n                priority = 'LOW'\n                score = 20\n            else:\n                priority = 'MINIMAL'\n                score = 10\n            \n            # Adjust based on CVSS if provided\n            if cvss_scores and cve in cvss_scores:\n                cvss = cvss_scores[cve]\n                if cvss >= 9.0 and epss < 0.3:\n                    # High CVSS but low EPSS - adjust slightly up\n                    score = min(score * 1.2, 100)\n            \n            priorities.append((cve, priority, score))\n        \n        # Sort by score descending\n        priorities.sort(key=lambda x: x[2], reverse=True)\n        return priorities\n\n# Example usage\nprioritizer = EPSSPrioritizer()\n\n# List of CVEs from vulnerability scan\ncves_to_assess = [\n    'CVE-2021-44228',  # Log4j\n    'CVE-2023-20198',  # Cisco IOS XE\n    'CVE-2019-11510',  # Pulse Secure VPN\n    'CVE-2018-13379',  # Fortinet FortiGate\n    'CVE-2020-1472'   # Zerologon\n]\n\n# Optional: Include CVSS scores if available\ncvss_data = {\n    'CVE-2021-44228': 10.0,\n    'CVE-2023-20198': 10.0,\n    'CVE-2019-11510': 10.0,\n    'CVE-2018-13379': 9.8,\n    'CVE-2020-1472': 10.0\n}\n\npriorities = prioritizer.prioritize(cves_to_assess, cvss_data)\n\nprint(\"Vulnerability Prioritization Results:\")\nprint(\"=\" * 50)\nfor cve, priority, score in priorities:\n    epss = prioritizer.get_scores([cve]).get(cve, 0)\n    cvss = cvss_data.get(cve, 'N/A')\n    print(f\"{cve:15} | Priority: {priority:8} | Score: {score:3.0f} | EPSS: {epss:.2%} | CVSS: {cvss}\")"
    }
  },
  "interpretation_guidance": {
    "decision_thresholds": {
      "deferred_patching": "< 0.1",
      "emergency_patching": "> 0.9",
      "priority_patching": "> 0.5",
      "standard_patching": "0.1 - 0.5"
    },
    "score_ranges": {
      "0.0-0.1": "Minimal - Very low exploitation likelihood",
      "0.1-0.3": "Low - Lower exploitation probability",
      "0.3-0.7": "Medium - Moderate exploitation likelihood",
      "0.7-0.9": "High - Significant exploitation risk",
      "0.9-1.0": "Critical - Very high exploitation probability"
    }
  },
  "last_updated": "2025-08-14T22:22:18.965482Z",
  "metadata": {
    "added_date": "2024-01-15",
    "alternatives": [
      "cvss",
      "vpr",
      "risk-based-scoring"
    ],
    "contributors": [
      "williamzujkowski"
    ],
    "last_updated": "2024-01-15",
    "related_sources": [
      "nvd-cve",
      "cisa-kev",
      "mitre-cve"
    ],
    "tags": [
      "vulnerability",
      "scoring",
      "epss",
      "exploitation-prediction",
      "risk-assessment",
      "machine-learning"
    ]
  },
  "name": "EPSS - Exploit Prediction Scoring System",
  "operational_guidance": {
    "best_practices": [
      "Combine EPSS with CVSS for comprehensive risk assessment",
      "Use percentile rankings to prioritize within score ranges",
      "Monitor score changes over time for trend analysis",
      "Set organizational thresholds based on risk tolerance",
      "Cross-reference with CISA KEV for validation",
      "Cache API responses for 24 hours",
      "Use bulk download for large-scale analysis"
    ],
    "common_pitfalls": [
      "Treating EPSS as absolute rather than probabilistic",
      "Ignoring environmental context in decisions",
      "Not considering asset criticality alongside scores",
      "Using outdated scores for decision making",
      "Exceeding API rate limits without caching"
    ],
    "cost_considerations": {
      "free_tier_limits": "1000 API requests per day",
      "paid_tiers": "N/A - Completely free service",
      "pricing_model": "free"
    },
    "recommended_update_frequency": "Daily for critical systems, weekly for standard"
  },
  "quality_metrics": {
    "accuracy": "Model AUC-ROC of 0.82, continuously improving",
    "community_rating": 4.7,
    "false_positive_rate": "~15% based on model validation",
    "last_verified": "2024-01-15",
    "reliability": "high",
    "timeliness": "Daily updates with latest threat intelligence"
  },
  "quality_score": 90,
  "subcategory": "scoring",
  "troubleshooting": {
    "common_errors": [
      {
        "error_code": "404",
        "meaning": "CVE not found in EPSS database",
        "solution": "Verify CVE format and check if it's a newly published CVE"
      },
      {
        "error_code": "429",
        "meaning": "Rate limit exceeded",
        "solution": "Implement caching or use bulk download for large queries"
      },
      {
        "error_code": "400",
        "meaning": "Invalid parameters",
        "solution": "Check parameter names and value formats"
      }
    ],
    "support_channels": {
      "community": "https://www.first.org/epss/faq",
      "documentation": "https://www.first.org/epss/api",
      "email": "epss-feedback@first.org",
      "github": "https://github.com/CERTCC/EPSS"
    }
  },
  "url": "https://www.first.org/epss"
}
