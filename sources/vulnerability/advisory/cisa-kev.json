{
  "api": {
    "base_url": "https://www.cisa.gov/sites/default/files/feeds",
    "endpoints": [
      {
        "description": "Retrieve the complete catalog of known exploited vulnerabilities",
        "headers": {
          "Accept": "application/json",
          "User-Agent": "YourApp/1.0"
        },
        "method": "GET",
        "parameters": [],
        "path": "/known_exploited_vulnerabilities.json",
        "rate_limit": {
          "notes": "No explicit rate limits, but respectful usage recommended. Consider caching for at least 1 hour.",
          "requests_per_day": null,
          "requests_per_hour": null,
          "requests_per_minute": null
        },
        "response_format": {
          "example": {
            "catalogVersion": "2024.01.15",
            "count": 1076,
            "dateReleased": "2024-01-15T17:00:00.000Z",
            "title": "CISA Catalog of Known Exploited Vulnerabilities",
            "vulnerabilities": [
              {
                "cveID": "CVE-2021-44228",
                "dateAdded": "2021-12-10",
                "dueDate": "2021-12-24",
                "knownRansomwareCampaignUse": "Known",
                "notes": "https://www.cisa.gov/uscert/apache-log4j-vulnerability-guidance",
                "product": "Log4j2",
                "requiredAction": "For all affected software assets for which updates are available, the only acceptable remediation actions are: 1) Apply updates; OR 2) remove affected assets from agency networks.",
                "shortDescription": "Apache Log4j2 2.0-beta9 through 2.15.0 JNDI features do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages can execute arbitrary code.",
                "vendorProject": "Apache",
                "vulnerabilityName": "Apache Log4j2 Remote Code Execution Vulnerability"
              }
            ]
          },
          "type": "JSON"
        }
      },
      {
        "description": "Retrieve the catalog in CSV format for spreadsheet analysis",
        "headers": {
          "Accept": "text/csv"
        },
        "method": "GET",
        "parameters": [],
        "path": "/known_exploited_vulnerabilities.csv",
        "response_format": {
          "example": "cveID,vendorProject,product,vulnerabilityName,dateAdded,shortDescription,requiredAction,dueDate,knownRansomwareCampaignUse,notes\nCVE-2021-44228,Apache,Log4j2,...",
          "type": "CSV"
        }
      }
    ],
    "type": "REST"
  },
  "authentication": {
    "documentation": "https://www.cisa.gov/known-exploited-vulnerabilities",
    "example_implementation": {
      "curl": "curl -O https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
      "javascript": "fetch('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json')",
      "python": "response = requests.get('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json')"
    },
    "required": false,
    "setup_instructions": [
      "No authentication required - this is a public feed",
      "Direct download available without registration",
      "Consider implementing caching to reduce load on CISA servers"
    ],
    "type": "none"
  },
  "authority": 100,
  "category": "vulnerability",
  "coverage": 95,
  "data_coverage": {
    "completeness": "100% of confirmed exploited vulnerabilities known to CISA",
    "data_types": [
      "CVE",
      "Exploitation Evidence",
      "Remediation Deadlines"
    ],
    "geographical": "global",
    "temporal": {
      "historical_data": "2021-11-03 to present",
      "latency": "Typically within days of exploitation confirmation",
      "update_frequency": "real-time as exploitation is confirmed"
    }
  },
  "data_format": {
    "compression": "none",
    "encoding": "UTF-8",
    "field_descriptions": {
      "cveID": "CVE identifier for the vulnerability",
      "dateAdded": "Date the vulnerability was added to the KEV catalog (YYYY-MM-DD)",
      "dueDate": "Federal agency deadline for remediation (YYYY-MM-DD)",
      "knownRansomwareCampaignUse": "Whether the vulnerability is known to be used in ransomware campaigns ('Known' or empty)",
      "notes": "Additional information or references (optional)",
      "product": "Name of the affected product",
      "requiredAction": "The required remediation action (typically 'Apply updates per vendor instructions')",
      "shortDescription": "Brief description of the vulnerability and its impact",
      "vendorProject": "Name of the vendor or open source project",
      "vulnerabilityName": "Short descriptive name for the vulnerability"
    },
    "primary_format": "JSON",
    "schemas": {
      "documentation": "https://www.cisa.gov/known-exploited-vulnerabilities"
    }
  },
  "description": "CISA's authoritative source of vulnerabilities that have been actively exploited in the wild. This catalog is part of Binding Operational Directive 22-01, requiring federal agencies to remediate listed vulnerabilities within specified timeframes. It represents the highest-priority vulnerabilities for defensive action.",
  "documentation": "https://www.cisa.gov/known-exploited-vulnerabilities",
  "format": "json",
  "id": "cisa-kev",
  "integration_examples": {
    "curl": {
      "basic_fetch": "# Download the complete KEV catalog\ncurl -O https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
      "check_cve": "# Check if specific CVE is in KEV catalog\nCVE=\"CVE-2021-44228\"\ncurl -s https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json | \\\n  jq --arg cve \"$CVE\" '.vulnerabilities[] | select(.cveID == $cve)'",
      "count_kevs": "# Get total count of KEVs\ncurl -s https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json | jq '.count'",
      "csv_download": "# Download CSV format for spreadsheet analysis\ncurl -O https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.csv",
      "pretty_print": "# Download and format with jq\ncurl -s https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json | jq '.'",
      "ransomware_kevs": "# Get ransomware-associated KEVs\ncurl -s https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json | \\\n  jq '.vulnerabilities[] | select(.knownRansomwareCampaignUse == \"Known\")' | \\\n  jq -s 'length'",
      "recent_additions": "# Show KEVs added in 2024\ncurl -s https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json | \\\n  jq '.vulnerabilities[] | select(.dateAdded | startswith(\"2024\"))' | \\\n  jq -s 'length'"
    },
    "go": {
      "basic_fetch": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\n\ntype KEVCatalog struct {\n    Title           string          `json:\"title\"`\n    CatalogVersion  string          `json:\"catalogVersion\"`\n    DateReleased    string          `json:\"dateReleased\"`\n    Count           int             `json:\"count\"`\n    Vulnerabilities []Vulnerability `json:\"vulnerabilities\"`\n}\n\ntype Vulnerability struct {\n    CVEID                      string `json:\"cveID\"`\n    VendorProject              string `json:\"vendorProject\"`\n    Product                    string `json:\"product\"`\n    VulnerabilityName          string `json:\"vulnerabilityName\"`\n    DateAdded                  string `json:\"dateAdded\"`\n    ShortDescription           string `json:\"shortDescription\"`\n    RequiredAction             string `json:\"requiredAction\"`\n    DueDate                    string `json:\"dueDate\"`\n    KnownRansomwareCampaignUse string `json:\"knownRansomwareCampaignUse\"`\n    Notes                      string `json:\"notes\"`\n}\n\nfunc fetchKEVCatalog() (*KEVCatalog, error) {\n    url := \"https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json\"\n    \n    client := &http.Client{Timeout: 30 * time.Second}\n    resp, err := client.Get(url)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to fetch KEV catalog: %w\", err)\n    }\n    defer resp.Body.Close()\n    \n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"HTTP %d: %s\", resp.StatusCode, resp.Status)\n    }\n    \n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read response: %w\", err)\n    }\n    \n    var catalog KEVCatalog\n    if err := json.Unmarshal(body, &catalog); err != nil {\n        return nil, fmt.Errorf(\"failed to parse JSON: %w\", err)\n    }\n    \n    return &catalog, nil\n}\n\nfunc main() {\n    catalog, err := fetchKEVCatalog()\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n        return\n    }\n    \n    fmt.Printf(\"CISA KEV Catalog\\n\")\n    fmt.Printf(\"Version: %s\\n\", catalog.CatalogVersion)\n    fmt.Printf(\"Released: %s\\n\", catalog.DateReleased)\n    fmt.Printf(\"Total KEVs: %d\\n\\n\", catalog.Count)\n    \n    // Count ransomware KEVs\n    ransomwareCount := 0\n    for _, vuln := range catalog.Vulnerabilities {\n        if vuln.KnownRansomwareCampaignUse == \"Known\" {\n            ransomwareCount++\n        }\n    }\n    fmt.Printf(\"Ransomware-associated: %d (%.1f%%)\\n\\n\", \n        ransomwareCount, \n        float64(ransomwareCount)/float64(catalog.Count)*100)\n    \n    // Show recent additions\n    fmt.Println(\"Recent Additions:\")\n    for i, vuln := range catalog.Vulnerabilities {\n        if i >= 5 {\n            break\n        }\n        fmt.Printf(\"- %s: %s %s (Added: %s)\\n\", \n            vuln.CVEID, \n            vuln.VendorProject, \n            vuln.Product, \n            vuln.DateAdded)\n    }\n}"
    },
    "javascript": {
      "basic_fetch": "// Fetch and display KEV catalog\nconst fetchKEVCatalog = async () => {\n  const url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';\n  \n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    \n    console.log(`Total KEVs: ${data.count}`);\n    console.log(`Catalog Version: ${data.catalogVersion}`);\n    console.log(`Last Updated: ${data.dateReleased}`);\n    \n    // Show first 5 KEVs\n    data.vulnerabilities.slice(0, 5).forEach(vuln => {\n      console.log(`\\n${vuln.cveID}: ${vuln.vulnerabilityName}`);\n      console.log(`  Vendor: ${vuln.vendorProject}`);\n      console.log(`  Added: ${vuln.dateAdded}`);\n      console.log(`  Due: ${vuln.dueDate}`);\n    });\n    \n    return data;\n  } catch (error) {\n    console.error('Error fetching KEV catalog:', error);\n    throw error;\n  }\n};\n\nfetchKEVCatalog();",
      "dashboard_example": "// Simple KEV dashboard generator\nclass KEVDashboard {\n  constructor(containerId) {\n    this.container = document.getElementById(containerId);\n    this.catalog = new KEVCatalog();\n  }\n  \n  async render() {\n    const data = await this.catalog.fetch();\n    \n    // Calculate statistics\n    const stats = this.calculateStats(data);\n    \n    // Generate HTML\n    this.container.innerHTML = `\n      <div class=\"kev-dashboard\">\n        <h2>CISA KEV Dashboard</h2>\n        \n        <div class=\"stats-grid\">\n          <div class=\"stat-card\">\n            <h3>Total KEVs</h3>\n            <p class=\"stat-value\">${stats.total}</p>\n          </div>\n          \n          <div class=\"stat-card\">\n            <h3>Ransomware KEVs</h3>\n            <p class=\"stat-value\">${stats.ransomware}</p>\n            <p class=\"stat-label\">${stats.ransomwarePercent}%</p>\n          </div>\n          \n          <div class=\"stat-card\">\n            <h3>Added This Week</h3>\n            <p class=\"stat-value\">${stats.recentAdditions}</p>\n          </div>\n          \n          <div class=\"stat-card\">\n            <h3>Overdue</h3>\n            <p class=\"stat-value\" style=\"color: red;\">${stats.overdue}</p>\n          </div>\n        </div>\n        \n        <div class=\"recent-kevs\">\n          <h3>Latest Additions</h3>\n          <ul>\n            ${stats.latestKEVs.map(kev => `\n              <li>\n                <strong>${kev.cveID}</strong> - ${kev.vendorProject} ${kev.product}\n                <br><small>Added: ${kev.dateAdded} | Due: ${kev.dueDate}</small>\n              </li>\n            `).join('')}\n          </ul>\n        </div>\n        \n        <div class=\"top-vendors\">\n          <h3>Most Affected Vendors</h3>\n          <ul>\n            ${stats.topVendors.map(([vendor, count]) => `\n              <li>${vendor}: ${count} vulnerabilities</li>\n            `).join('')}\n          </ul>\n        </div>\n      </div>\n    `;\n  }\n  \n  calculateStats(data) {\n    const today = new Date();\n    const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);\n    \n    // Count ransomware KEVs\n    const ransomware = data.vulnerabilities.filter(\n      v => v.knownRansomwareCampaignUse === 'Known'\n    ).length;\n    \n    // Count recent additions\n    const recentAdditions = data.vulnerabilities.filter(\n      v => new Date(v.dateAdded) >= weekAgo\n    ).length;\n    \n    // Count overdue\n    const overdue = data.vulnerabilities.filter(\n      v => new Date(v.dueDate) < today\n    ).length;\n    \n    // Top vendors\n    const vendorCounts = {};\n    data.vulnerabilities.forEach(v => {\n      vendorCounts[v.vendorProject] = (vendorCounts[v.vendorProject] || 0) + 1;\n    });\n    const topVendors = Object.entries(vendorCounts)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5);\n    \n    // Latest KEVs\n    const latestKEVs = [...data.vulnerabilities]\n      .sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded))\n      .slice(0, 5);\n    \n    return {\n      total: data.count,\n      ransomware,\n      ransomwarePercent: ((ransomware / data.count) * 100).toFixed(1),\n      recentAdditions,\n      overdue,\n      topVendors,\n      latestKEVs\n    };\n  }\n}\n\n// Initialize dashboard\nif (typeof document !== 'undefined') {\n  const dashboard = new KEVDashboard('kev-container');\n  dashboard.render();\n  \n  // Refresh every hour\n  setInterval(() => dashboard.render(), 3600000);\n}",
      "filter_functions": "// KEV filtering utilities\nclass KEVCatalog {\n  constructor() {\n    this.url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';\n    this.data = null;\n    this.lastFetch = null;\n  }\n  \n  async fetch(forceRefresh = false) {\n    // Cache for 1 hour\n    if (!forceRefresh && this.data && this.lastFetch) {\n      const age = Date.now() - this.lastFetch;\n      if (age < 3600000) { // 1 hour in milliseconds\n        return this.data;\n      }\n    }\n    \n    const response = await fetch(this.url);\n    this.data = await response.json();\n    this.lastFetch = Date.now();\n    return this.data;\n  }\n  \n  async getRecentKEVs(daysBack = 7) {\n    const data = await this.fetch();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysBack);\n    \n    return data.vulnerabilities.filter(vuln => {\n      const dateAdded = new Date(vuln.dateAdded);\n      return dateAdded >= cutoffDate;\n    });\n  }\n  \n  async getRansomwareKEVs() {\n    const data = await this.fetch();\n    return data.vulnerabilities.filter(\n      vuln => vuln.knownRansomwareCampaignUse === 'Known'\n    );\n  }\n  \n  async checkCVE(cveId) {\n    const data = await this.fetch();\n    return data.vulnerabilities.find(vuln => vuln.cveID === cveId);\n  }\n  \n  async getByVendor(vendor) {\n    const data = await this.fetch();\n    return data.vulnerabilities.filter(\n      vuln => vuln.vendorProject.toLowerCase().includes(vendor.toLowerCase())\n    );\n  }\n  \n  async getOverdue() {\n    const data = await this.fetch();\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    return data.vulnerabilities.filter(vuln => {\n      const dueDate = new Date(vuln.dueDate);\n      return dueDate < today;\n    }).map(vuln => ({\n      ...vuln,\n      daysOverdue: Math.floor((today - new Date(vuln.dueDate)) / (1000 * 60 * 60 * 24))\n    })).sort((a, b) => b.daysOverdue - a.daysOverdue);\n  }\n}\n\n// Usage\nconst kev = new KEVCatalog();\n\n// Get recent additions\nkev.getRecentKEVs(30).then(recent => {\n  console.log(`${recent.length} KEVs added in last 30 days`);\n});\n\n// Check if CVE is in catalog\nkev.checkCVE('CVE-2021-44228').then(result => {\n  if (result) {\n    console.log('CVE-2021-44228 is a known exploited vulnerability!');\n    console.log(`Action required: ${result.requiredAction}`);\n  }\n});"
    },
    "python": {
      "basic_fetch": "import requests\nimport json\nfrom datetime import datetime\n\n# Fetch the CISA KEV catalog\nurl = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'\nresponse = requests.get(url)\ndata = response.json()\n\nprint(f\"Catalog Version: {data['catalogVersion']}\")\nprint(f\"Total KEVs: {data['count']}\")\nprint(f\"Last Updated: {data['dateReleased']}\")\n\n# Show recent additions\nfor vuln in data['vulnerabilities'][:5]:\n    print(f\"\\n{vuln['cveID']} - {vuln['vendorProject']} {vuln['product']}\")\n    print(f\"  Added: {vuln['dateAdded']}\")\n    print(f\"  Due: {vuln['dueDate']}\")\n    print(f\"  Ransomware: {vuln.get('knownRansomwareCampaignUse', 'Unknown')}\")",
      "check_products": "import requests\nfrom typing import List, Dict\n\ndef check_products_for_kevs(products: List[str]) -> Dict[str, List[Dict]]:\n    \"\"\"Check if specific products have KEVs\"\"\"\n    url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'\n    response = requests.get(url)\n    data = response.json()\n    \n    results = {product: [] for product in products}\n    \n    for vuln in data['vulnerabilities']:\n        for product in products:\n            if product.lower() in vuln['product'].lower() or \\\n               product.lower() in vuln['vendorProject'].lower():\n                results[product].append(vuln)\n    \n    return results\n\n# Check specific products\nproducts_to_check = ['Windows', 'Chrome', 'Apache']\nresults = check_products_for_kevs(products_to_check)\n\nfor product, kevs in results.items():\n    print(f\"\\n{product}: {len(kevs)} KEVs found\")\n    for kev in kevs[:3]:  # Show first 3\n        print(f\"  - {kev['cveID']}: {kev['shortDescription'][:80]}...\")",
      "filter_by_date": "import requests\nfrom datetime import datetime, timedelta\n\ndef get_recent_kevs(days_back=7):\n    \"\"\"Get KEVs added in the last N days\"\"\"\n    url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'\n    response = requests.get(url)\n    data = response.json()\n    \n    cutoff_date = datetime.now() - timedelta(days=days_back)\n    recent_kevs = []\n    \n    for vuln in data['vulnerabilities']:\n        date_added = datetime.strptime(vuln['dateAdded'], '%Y-%m-%d')\n        if date_added >= cutoff_date:\n            recent_kevs.append(vuln)\n    \n    return recent_kevs\n\n# Get KEVs from last week\nrecent = get_recent_kevs(7)\nprint(f\"Found {len(recent)} KEVs added in the last week:\")\nfor kev in recent:\n    print(f\"- {kev['cveID']}: {kev['vulnerabilityName']}\")",
      "full_example": "#!/usr/bin/env python3\n\"\"\"\nCISA KEV Monitor - Complete working example\n\"\"\"\n\nimport requests\nimport json\nimport sqlite3\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nimport time\n\nclass CISAKEVClient:\n    def __init__(self, cache_file: str = 'kev_cache.db'):\n        self.url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'\n        self.cache_file = cache_file\n        self._init_cache()\n    \n    def _init_cache(self):\n        \"\"\"Initialize SQLite cache database\"\"\"\n        conn = sqlite3.connect(self.cache_file)\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS kev_cache (\n                cve_id TEXT PRIMARY KEY,\n                vendor TEXT,\n                product TEXT,\n                name TEXT,\n                description TEXT,\n                date_added DATE,\n                due_date DATE,\n                action TEXT,\n                ransomware TEXT,\n                notes TEXT,\n                last_seen TIMESTAMP\n            )\n        ''')\n        conn.commit()\n        conn.close()\n    \n    def fetch_catalog(self, use_cache: bool = True, cache_hours: int = 1) -> Dict:\n        \"\"\"Fetch KEV catalog with optional caching\"\"\"\n        if use_cache:\n            # Check if we have recent data\n            conn = sqlite3.connect(self.cache_file)\n            cursor = conn.cursor()\n            cursor.execute(\n                'SELECT MAX(last_seen) FROM kev_cache'\n            )\n            result = cursor.fetchone()\n            conn.close()\n            \n            if result[0]:\n                last_update = datetime.fromisoformat(result[0])\n                if datetime.now() - last_update < timedelta(hours=cache_hours):\n                    return self._load_from_cache()\n        \n        # Fetch fresh data\n        response = requests.get(self.url, timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        \n        # Update cache\n        self._update_cache(data)\n        \n        return data\n    \n    def _update_cache(self, data: Dict):\n        \"\"\"Update local cache with fresh data\"\"\"\n        conn = sqlite3.connect(self.cache_file)\n        cursor = conn.cursor()\n        \n        now = datetime.now().isoformat()\n        \n        for vuln in data['vulnerabilities']:\n            cursor.execute('''\n                INSERT OR REPLACE INTO kev_cache VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (\n                vuln['cveID'],\n                vuln['vendorProject'],\n                vuln['product'],\n                vuln['vulnerabilityName'],\n                vuln['shortDescription'],\n                vuln['dateAdded'],\n                vuln['dueDate'],\n                vuln['requiredAction'],\n                vuln.get('knownRansomwareCampaignUse', ''),\n                vuln.get('notes', ''),\n                now\n            ))\n        \n        conn.commit()\n        conn.close()\n    \n    def _load_from_cache(self) -> Dict:\n        \"\"\"Load data from cache\"\"\"\n        conn = sqlite3.connect(self.cache_file)\n        cursor = conn.cursor()\n        \n        cursor.execute('SELECT COUNT(*) FROM kev_cache')\n        count = cursor.fetchone()[0]\n        \n        cursor.execute('''\n            SELECT cve_id, vendor, product, name, description, \n                   date_added, due_date, action, ransomware, notes\n            FROM kev_cache\n            ORDER BY date_added DESC\n        ''')\n        \n        vulnerabilities = []\n        for row in cursor.fetchall():\n            vulnerabilities.append({\n                'cveID': row[0],\n                'vendorProject': row[1],\n                'product': row[2],\n                'vulnerabilityName': row[3],\n                'shortDescription': row[4],\n                'dateAdded': row[5],\n                'dueDate': row[6],\n                'requiredAction': row[7],\n                'knownRansomwareCampaignUse': row[8],\n                'notes': row[9]\n            })\n        \n        conn.close()\n        \n        return {\n            'count': count,\n            'vulnerabilities': vulnerabilities,\n            'cached': True\n        }\n    \n    def check_cve(self, cve_id: str) -> Optional[Dict]:\n        \"\"\"Check if a specific CVE is in the KEV catalog\"\"\"\n        data = self.fetch_catalog()\n        \n        for vuln in data['vulnerabilities']:\n            if vuln['cveID'] == cve_id:\n                return vuln\n        \n        return None\n    \n    def get_overdue(self) -> List[Dict]:\n        \"\"\"Get KEVs past their remediation deadline\"\"\"\n        data = self.fetch_catalog()\n        today = datetime.now().date()\n        overdue = []\n        \n        for vuln in data['vulnerabilities']:\n            due_date = datetime.strptime(vuln['dueDate'], '%Y-%m-%d').date()\n            if due_date < today:\n                vuln['days_overdue'] = (today - due_date).days\n                overdue.append(vuln)\n        \n        return sorted(overdue, key=lambda x: x['days_overdue'], reverse=True)\n    \n    def get_upcoming_deadlines(self, days: int = 14) -> List[Dict]:\n        \"\"\"Get KEVs with upcoming remediation deadlines\"\"\"\n        data = self.fetch_catalog()\n        today = datetime.now().date()\n        cutoff = today + timedelta(days=days)\n        upcoming = []\n        \n        for vuln in data['vulnerabilities']:\n            due_date = datetime.strptime(vuln['dueDate'], '%Y-%m-%d').date()\n            if today <= due_date <= cutoff:\n                vuln['days_remaining'] = (due_date - today).days\n                upcoming.append(vuln)\n        \n        return sorted(upcoming, key=lambda x: x['days_remaining'])\n    \n    def generate_report(self) -> str:\n        \"\"\"Generate a summary report of the KEV catalog\"\"\"\n        data = self.fetch_catalog()\n        \n        # Statistics\n        total = data['count']\n        ransomware = sum(1 for v in data['vulnerabilities'] \n                        if v.get('knownRansomwareCampaignUse', '').lower() == 'known')\n        \n        # Recent additions\n        week_ago = (datetime.now() - timedelta(days=7)).date()\n        recent = sum(1 for v in data['vulnerabilities']\n                    if datetime.strptime(v['dateAdded'], '%Y-%m-%d').date() >= week_ago)\n        \n        # Vendor breakdown\n        vendors = {}\n        for vuln in data['vulnerabilities']:\n            vendor = vuln['vendorProject']\n            vendors[vendor] = vendors.get(vendor, 0) + 1\n        \n        top_vendors = sorted(vendors.items(), key=lambda x: x[1], reverse=True)[:5]\n        \n        report = f\"\"\"\nCISA KEV Catalog Report\n{'=' * 50}\nGenerated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\nCatalog Version: {data.get('catalogVersion', 'Unknown')}\n\nSTATISTICS\n{'-' * 20}\nTotal KEVs: {total}\nRansomware-associated: {ransomware} ({ransomware/total*100:.1f}%)\nAdded in last 7 days: {recent}\n\nTOP AFFECTED VENDORS\n{'-' * 20}\n\"\"\"\n        \n        for vendor, count in top_vendors:\n            report += f\"{vendor}: {count} vulnerabilities\\n\"\n        \n        # Check for overdue\n        overdue = self.get_overdue()\n        if overdue:\n            report += f\"\\nOVERDUE REMEDIATIONS\\n{'-' * 20}\\n\"\n            for vuln in overdue[:5]:\n                report += f\"{vuln['cveID']}: {vuln['days_overdue']} days overdue\\n\"\n        \n        # Upcoming deadlines\n        upcoming = self.get_upcoming_deadlines(14)\n        if upcoming:\n            report += f\"\\nUPCOMING DEADLINES (14 days)\\n{'-' * 20}\\n\"\n            for vuln in upcoming[:5]:\n                report += f\"{vuln['cveID']}: {vuln['days_remaining']} days remaining\\n\"\n        \n        return report\n\n# Example usage\nif __name__ == '__main__':\n    client = CISAKEVClient()\n    \n    # Generate report\n    print(client.generate_report())\n    \n    # Check specific CVE\n    cve = 'CVE-2021-44228'\n    result = client.check_cve(cve)\n    if result:\n        print(f\"\\n{cve} is in KEV catalog:\")\n        print(f\"  Vendor: {result['vendorProject']}\")\n        print(f\"  Product: {result['product']}\")\n        print(f\"  Added: {result['dateAdded']}\")\n        print(f\"  Ransomware: {result.get('knownRansomwareCampaignUse', 'Unknown')}\")\n    else:\n        print(f\"\\n{cve} is NOT in KEV catalog\")",
      "ransomware_filter": "import requests\n\ndef get_ransomware_kevs():\n    \"\"\"Get all KEVs associated with ransomware campaigns\"\"\"\n    url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'\n    response = requests.get(url)\n    data = response.json()\n    \n    ransomware_kevs = [\n        vuln for vuln in data['vulnerabilities']\n        if vuln.get('knownRansomwareCampaignUse', '').lower() == 'known'\n    ]\n    \n    return ransomware_kevs\n\n# Get ransomware-associated KEVs\nransomware = get_ransomware_kevs()\nprint(f\"Found {len(ransomware)} KEVs used in ransomware campaigns:\")\n\n# Group by vendor\nvendors = {}\nfor kev in ransomware:\n    vendor = kev['vendorProject']\n    if vendor not in vendors:\n        vendors[vendor] = []\n    vendors[vendor].append(kev)\n\nfor vendor, kevs in sorted(vendors.items(), key=lambda x: len(x[1]), reverse=True)[:5]:\n    print(f\"\\n{vendor}: {len(kevs)} ransomware KEVs\")"
    }
  },
  "last_updated": "2025-08-14T22:22:18.965482Z",
  "metadata": {
    "added_date": "2024-01-15",
    "alternatives": [
      "exploit-db",
      "metasploit-db"
    ],
    "contributors": [
      "williamzujkowski"
    ],
    "last_updated": "2024-01-15",
    "related_sources": [
      "nvd-cve",
      "epss",
      "mitre-cve"
    ],
    "tags": [
      "vulnerability",
      "exploited",
      "official-source",
      "government",
      "compliance",
      "ransomware",
      "binding-operational-directive"
    ]
  },
  "name": "CISA Known Exploited Vulnerabilities Catalog",
  "operational_guidance": {
    "best_practices": [
      "Automate daily checks for new KEV additions",
      "Alert on new KEVs affecting your technology stack",
      "Track remediation progress against due dates",
      "Prioritize KEVs with 'Known' ransomware association",
      "Integrate with vulnerability scanners for automated detection",
      "Cache the catalog locally with 1-hour refresh",
      "Monitor both additions and modifications to existing entries"
    ],
    "common_pitfalls": [
      "Not monitoring for new additions regularly",
      "Ignoring due dates for remediation",
      "Not tracking vendor-specific KEVs",
      "Missing KEVs due to product name variations",
      "Not considering the federal compliance requirements"
    ],
    "cost_considerations": {
      "free_tier_limits": "Unlimited - Public government resource",
      "paid_tiers": "N/A",
      "pricing_model": "free"
    },
    "recommended_update_frequency": "Daily check for new additions"
  },
  "quality_metrics": {
    "accuracy": "Authoritative U.S. government source with verified exploitation",
    "community_rating": 5.0,
    "false_positive_rate": "0% - Only confirmed exploitations are listed",
    "last_verified": "2024-01-15",
    "reliability": "high",
    "timeliness": "Rapid addition of newly exploited vulnerabilities"
  },
  "quality_score": 90,
  "regulatory_context": {
    "applies_to": "Federal Civilian Executive Branch Agencies",
    "description": "Federal agencies are required to remediate vulnerabilities on this list within specified timeframes",
    "name": "Binding Operational Directive 22-01",
    "remediation_timeframes": {
      "catalog_vulnerabilities": "Within 6 months of BOD issuance (by May 2, 2022)",
      "new_vulnerabilities": "Within 2 weeks of catalog addition"
    },
    "url": "https://www.cisa.gov/binding-operational-directive-22-01"
  },
  "subcategory": "exploited",
  "troubleshooting": {
    "common_errors": [
      {
        "error_code": "404",
        "meaning": "Feed URL has changed",
        "solution": "Check CISA website for updated feed location"
      },
      {
        "error_code": "Connection timeout",
        "meaning": "Network issues or CISA server load",
        "solution": "Implement retry logic with exponential backoff"
      },
      {
        "error_code": "JSON parsing error",
        "meaning": "Feed format has changed",
        "solution": "Check for updates to the feed schema"
      }
    ],
    "support_channels": {
      "documentation": "https://www.cisa.gov/known-exploited-vulnerabilities",
      "email": "vulnerability@cisa.dhs.gov",
      "issues": "https://github.com/cisagov/known-exploited-vulnerabilities"
    }
  },
  "url": "https://www.cisa.gov/known-exploited-vulnerabilities-catalog"
}
