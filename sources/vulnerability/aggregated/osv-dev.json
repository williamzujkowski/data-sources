{
  "api": {
    "base_url": "https://api.osv.dev/v1",
    "ecosystems": [
      "PyPI",
      "npm",
      "Go",
      "Packagist",
      "Maven",
      "NuGet",
      "RubyGems",
      "crates.io",
      "Hex",
      "Pub",
      "ConanCenter",
      "Linux",
      "OSS-Fuzz",
      "GitHub Actions",
      "Android"
    ],
    "endpoints": [
      {
        "description": "Query for vulnerabilities - COMPLETELY FREE!",
        "method": "POST",
        "parameters": [
          {
            "description": "Package to query",
            "example": {
              "ecosystem": "PyPI",
              "name": "django"
            },
            "name": "package",
            "required": false,
            "type": "object"
          },
          {
            "description": "Package version",
            "example": "3.2.0",
            "name": "version",
            "required": false,
            "type": "string"
          },
          {
            "description": "Git commit hash",
            "example": "6879efc2c1596d11a6a6ad296f80063b558d5e0f",
            "name": "commit",
            "required": false,
            "type": "string"
          },
          {
            "description": "Pagination token",
            "name": "page_token",
            "required": false,
            "type": "string"
          }
        ],
        "path": "/query",
        "rate_limit": {
          "notes": "NO RATE LIMITS! Completely free to use without authentication!"
        },
        "request_body": {
          "example": {
            "package": {
              "ecosystem": "npm",
              "name": "express"
            },
            "version": "4.17.1"
          },
          "type": "JSON"
        },
        "response_format": {
          "example": {
            "vulns": [
              {
                "aliases": [
                  "CVE-2021-xxxxx"
                ],
                "database_specific": {
                  "severity": "HIGH"
                },
                "details": "Detailed description",
                "id": "GHSA-xxxx-xxxx-xxxx",
                "modified": "2024-01-15T00:00:00Z",
                "summary": "Vulnerability summary"
              }
            ]
          },
          "type": "JSON"
        }
      },
      {
        "description": "Get vulnerability details - FREE!",
        "method": "GET",
        "parameters": [
          {
            "description": "Vulnerability ID",
            "example": "GHSA-2qrg-x229-3v8q",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "path": "/vulns/{id}"
      },
      {
        "description": "Batch query for affected versions - FREE!",
        "method": "POST",
        "path": "/query_affected",
        "request_body": {
          "example": {
            "queries": [
              {
                "package": {
                  "ecosystem": "PyPI",
                  "name": "requests"
                },
                "version": "2.25.0"
              },
              {
                "package": {
                  "ecosystem": "npm",
                  "name": "lodash"
                },
                "version": "4.17.20"
              }
            ]
          },
          "type": "JSON"
        }
      },
      {
        "description": "Batch vulnerability query - FREE!",
        "method": "POST",
        "path": "/querybatch",
        "request_body": {
          "example": {
            "queries": [
              {
                "package": {
                  "ecosystem": "Go",
                  "name": "github.com/gorilla/websocket"
                }
              }
            ]
          },
          "type": "JSON"
        }
      }
    ],
    "type": "REST"
  },
  "authentication": {
    "notes": "OSV is COMPLETELY FREE with NO AUTHENTICATION required! No API keys, no rate limits, no registration. Just start using it!",
    "required": false,
    "type": "none"
  },
  "category": "vulnerability",
  "coverage": {
    "data_sources": [
      "GitHub Advisory Database",
      "PyPI Advisory Database",
      "Go Vulnerability Database",
      "Rust Advisory Database",
      "npm Security Advisories",
      "Linux Kernel CVEs",
      "OSS-Fuzz",
      "RubyGems Advisory Database",
      "Packagist Security Advisories",
      "PYSEC",
      "Android Security Bulletins",
      "Debian Security Tracker"
    ],
    "ecosystems": "15+ programming language ecosystems",
    "update_frequency": "Real-time as sources update",
    "volume": "50,000+ vulnerabilities and growing"
  },
  "data_format": {
    "encoding": "UTF-8",
    "field_descriptions": {
      "affected": "Affected package versions and ranges",
      "aliases": "Other identifiers (CVE, GHSA, etc.)",
      "credits": "Reporters and contributors",
      "details": "Detailed description",
      "id": "Unique vulnerability identifier",
      "modified": "Last modification time",
      "published": "Publication time",
      "references": "URLs with more information",
      "severity": "CVSS score and severity level",
      "summary": "One-line summary",
      "withdrawn": "Withdrawal time if retracted"
    },
    "primary_format": "JSON",
    "schemas": {
      "documentation": "https://google.github.io/osv.dev/data/",
      "osv_schema": "https://ossf.github.io/osv-schema/"
    }
  },
  "description": "Google's unified vulnerability database providing FREE access to security vulnerabilities from multiple sources. Aggregates data from GitHub, PyPI, npm, Go, Rust, Linux kernel, and more. Completely free with no rate limits!",
  "documentation": "https://google.github.io/osv.dev/api/",
  "id": "osv-dev",
  "integration_examples": {
    "curl": {
      "batch_query": "# Batch query multiple packages - FREE!\ncurl -X POST 'https://api.osv.dev/v1/querybatch' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"queries\": [{\"package\": {\"ecosystem\": \"npm\", \"name\": \"express\"}}, {\"package\": {\"ecosystem\": \"PyPI\", \"name\": \"flask\"}}]}'",
      "download_database": "# Download entire OSV database - FREE!\n# Each ecosystem has its own downloadable database\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/PyPI/all.zip'\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/npm/all.zip'\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/Go/all.zip'",
      "get_vulnerability": "# Get vulnerability details - FREE!\ncurl 'https://api.osv.dev/v1/vulns/GHSA-2qrg-x229-3v8q'",
      "query_git_commit": "# Query vulnerabilities by git commit - FREE!\ncurl -X POST 'https://api.osv.dev/v1/query' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"commit\": \"6879efc2c1596d11a6a6ad296f80063b558d5e0f\"}'",
      "query_package": "# Query package vulnerabilities - FREE!\ncurl -X POST 'https://api.osv.dev/v1/query' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"package\": {\"ecosystem\": \"PyPI\", \"name\": \"django\"}, \"version\": \"3.2.0\"}'"
    },
    "javascript": {
      "client": "// OSV.dev JavaScript Client - COMPLETELY FREE!\nclass OSVClient {\n  constructor() {\n    this.baseUrl = 'https://api.osv.dev/v1';\n  }\n  \n  async queryPackage(ecosystem, name, version = null) {\n    const payload = {\n      package: { ecosystem, name }\n    };\n    \n    if (version) {\n      payload.version = version;\n    }\n    \n    const response = await fetch(`${this.baseUrl}/query`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    });\n    \n    const data = await response.json();\n    return data.vulns || [];\n  }\n  \n  async getVulnerability(id) {\n    const response = await fetch(`${this.baseUrl}/vulns/${id}`);\n    return response.json();\n  }\n  \n  async batchQuery(packages) {\n    const queries = packages.map(pkg => ({\n      package: {\n        ecosystem: pkg.ecosystem,\n        name: pkg.name\n      },\n      ...(pkg.version && { version: pkg.version })\n    }));\n    \n    const response = await fetch(`${this.baseUrl}/querybatch`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ queries })\n    });\n    \n    const data = await response.json();\n    return data.results || [];\n  }\n  \n  async scanPackageJson(packageJson) {\n    const packages = [];\n    \n    // Add dependencies\n    for (const [name, version] of Object.entries(packageJson.dependencies || {})) {\n      packages.push({\n        ecosystem: 'npm',\n        name,\n        version: version.replace(/[^0-9.]/g, '')\n      });\n    }\n    \n    // Add devDependencies\n    for (const [name, version] of Object.entries(packageJson.devDependencies || {})) {\n      packages.push({\n        ecosystem: 'npm',\n        name,\n        version: version.replace(/[^0-9.]/g, '')\n      });\n    }\n    \n    return this.batchQuery(packages);\n  }\n}\n\n// Usage - ALL FREE!\nconst client = new OSVClient();\n\n// Check a single package\nclient.queryPackage('npm', 'express', '4.17.1').then(vulns => {\n  console.log(`Found ${vulns.length} vulnerabilities`);\n  vulns.forEach(v => {\n    console.log(`- ${v.id}: ${v.summary}`);\n  });\n});\n\n// Batch check multiple packages\nconst packages = [\n  { ecosystem: 'npm', name: 'lodash', version: '4.17.20' },\n  { ecosystem: 'PyPI', name: 'requests', version: '2.25.0' }\n];\n\nclient.batchQuery(packages).then(results => {\n  results.forEach((result, i) => {\n    const pkg = packages[i];\n    console.log(`\\n${pkg.ecosystem}:${pkg.name}@${pkg.version}`);\n    console.log(`Vulnerabilities: ${result.vulns?.length || 0}`);\n  });\n});"
    },
    "python": {
      "basic_query": "import requests\nimport json\n\n# Query for vulnerabilities - COMPLETELY FREE!\nurl = 'https://api.osv.dev/v1/query'\n\n# Check a Python package\npayload = {\n    'package': {\n        'ecosystem': 'PyPI',\n        'name': 'django'\n    },\n    'version': '3.2.0'\n}\n\nresponse = requests.post(url, json=payload)\nvulns = response.json().get('vulns', [])\n\nprint(f\"Found {len(vulns)} vulnerabilities (FREE API!)\\n\")\n\nfor vuln in vulns:\n    print(f\"\ud83d\udd34 {vuln['id']}\")\n    print(f\"   Summary: {vuln.get('summary', 'N/A')}\")\n    print(f\"   Severity: {vuln.get('database_specific', {}).get('severity', 'Unknown')}\")\n    print(f\"   Aliases: {', '.join(vuln.get('aliases', []))}\")\n    print()",
      "comprehensive_scanner": "#!/usr/bin/env python3\n\"\"\"\nOSV.dev Vulnerability Scanner - COMPLETELY FREE!\nNo API key or rate limits - scan all your dependencies!\n\"\"\"\n\nimport requests\nimport json\nimport subprocess\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nclass OSVScanner:\n    def __init__(self):\n        self.base_url = 'https://api.osv.dev/v1'\n    \n    def scan_package(self, ecosystem: str, name: str, version: str = None) -> List[Dict]:\n        \"\"\"Scan a package for vulnerabilities - FREE!\"\"\"\n        \n        payload = {\n            'package': {\n                'ecosystem': ecosystem,\n                'name': name\n            }\n        }\n        \n        if version:\n            payload['version'] = version\n        \n        response = requests.post(f'{self.base_url}/query', json=payload)\n        \n        if response.status_code == 200:\n            return response.json().get('vulns', [])\n        return []\n    \n    def get_vulnerability(self, vuln_id: str) -> Dict:\n        \"\"\"Get detailed vulnerability info - FREE!\"\"\"\n        \n        response = requests.get(f'{self.base_url}/vulns/{vuln_id}')\n        \n        if response.status_code == 200:\n            return response.json()\n        return {}\n    \n    def batch_scan(self, packages: List[Dict]) -> Dict[str, List]:\n        \"\"\"Scan multiple packages at once - FREE!\"\"\"\n        \n        queries = []\n        for pkg in packages:\n            query = {'package': {\n                'ecosystem': pkg['ecosystem'],\n                'name': pkg['name']\n            }}\n            if 'version' in pkg:\n                query['version'] = pkg['version']\n            queries.append(query)\n        \n        payload = {'queries': queries}\n        response = requests.post(f'{self.base_url}/querybatch', json=payload)\n        \n        results = {}\n        if response.status_code == 200:\n            data = response.json()\n            for i, result in enumerate(data.get('results', [])):\n                pkg_key = f\"{packages[i]['ecosystem']}:{packages[i]['name']}\"\n                results[pkg_key] = result.get('vulns', [])\n        \n        return results\n    \n    def scan_requirements_txt(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Python requirements.txt - FREE!\"\"\"\n        \n        packages = []\n        with open(file_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    # Parse package name and version\n                    if '==' in line:\n                        name, version = line.split('==')\n                        packages.append({\n                            'ecosystem': 'PyPI',\n                            'name': name.strip(),\n                            'version': version.strip()\n                        })\n                    elif '>=' in line or '<=' in line or '~=' in line:\n                        name = line.split('[')[0].split('<')[0].split('>')[0].split('~')[0]\n                        packages.append({\n                            'ecosystem': 'PyPI',\n                            'name': name.strip()\n                        })\n        \n        return self.batch_scan(packages)\n    \n    def scan_package_json(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Node.js package.json - FREE!\"\"\"\n        \n        with open(file_path, 'r') as f:\n            data = json.load(f)\n        \n        packages = []\n        \n        # Scan dependencies\n        for name, version in data.get('dependencies', {}).items():\n            # Clean version string\n            version = version.lstrip('^~')\n            packages.append({\n                'ecosystem': 'npm',\n                'name': name,\n                'version': version if version[0].isdigit() else None\n            })\n        \n        # Scan devDependencies\n        for name, version in data.get('devDependencies', {}).items():\n            version = version.lstrip('^~')\n            packages.append({\n                'ecosystem': 'npm',\n                'name': name,\n                'version': version if version[0].isdigit() else None\n            })\n        \n        return self.batch_scan(packages)\n    \n    def scan_go_mod(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Go modules - FREE!\"\"\"\n        \n        packages = []\n        with open(file_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith('require') or '\\t' in line:\n                    parts = line.split()\n                    if len(parts) >= 2 and '.' in parts[0]:\n                        name = parts[0]\n                        version = parts[1] if len(parts) > 1 else None\n                        packages.append({\n                            'ecosystem': 'Go',\n                            'name': name,\n                            'version': version\n                        })\n        \n        return self.batch_scan(packages)\n    \n    def scan_git_commit(self, commit_hash: str) -> List[Dict]:\n        \"\"\"Scan a Git commit for vulnerabilities - FREE!\"\"\"\n        \n        payload = {'commit': commit_hash}\n        response = requests.post(f'{self.base_url}/query', json=payload)\n        \n        if response.status_code == 200:\n            return response.json().get('vulns', [])\n        return []\n    \n    def format_vulnerability(self, vuln: Dict) -> str:\n        \"\"\"Format vulnerability for display\"\"\"\n        \n        severity = vuln.get('database_specific', {}).get('severity', 'UNKNOWN')\n        severity_emoji = {\n            'CRITICAL': '\ud83d\udd34',\n            'HIGH': '\ud83d\udfe0',\n            'MODERATE': '\ud83d\udfe1',\n            'MEDIUM': '\ud83d\udfe1',\n            'LOW': '\ud83d\udfe2'\n        }.get(severity.upper(), '\u26aa')\n        \n        output = f\"{severity_emoji} {vuln['id']}\\n\"\n        output += f\"   Summary: {vuln.get('summary', 'N/A')}\\n\"\n        output += f\"   Severity: {severity}\\n\"\n        \n        if vuln.get('aliases'):\n            output += f\"   Aliases: {', '.join(vuln['aliases'])}\\n\"\n        \n        if vuln.get('affected'):\n            for affected in vuln['affected']:\n                if affected.get('ranges'):\n                    output += f\"   Affected: {affected['ranges'][0].get('type', 'version')} \"\n                    events = affected['ranges'][0].get('events', [])\n                    if events:\n                        output += f\"{events[0].get('introduced', '')} - {events[-1].get('fixed', 'latest')}\\n\"\n        \n        return output\n\n# Example usage - ALL FREE!\nif __name__ == '__main__':\n    scanner = OSVScanner()\n    \n    # Scan a single package\n    print(\"\\n=== Scanning Django (FREE) ===\")\n    vulns = scanner.scan_package('PyPI', 'django', '3.2.0')\n    for vuln in vulns:\n        print(scanner.format_vulnerability(vuln))\n    \n    # Batch scan multiple packages\n    print(\"\\n=== Batch Scanning Popular Packages ===\")\n    packages = [\n        {'ecosystem': 'npm', 'name': 'express', 'version': '4.17.1'},\n        {'ecosystem': 'PyPI', 'name': 'requests', 'version': '2.25.0'},\n        {'ecosystem': 'Go', 'name': 'github.com/gin-gonic/gin', 'version': 'v1.7.0'}\n    ]\n    \n    results = scanner.batch_scan(packages)\n    for pkg_name, vulns in results.items():\n        if vulns:\n            print(f\"\\n{pkg_name}: {len(vulns)} vulnerabilities found\")\n            for vuln in vulns[:2]:  # Show first 2\n                print(f\"  - {vuln['id']}: {vuln.get('summary', 'N/A')[:80]}\")\n    \n    # Scan local project files\n    if Path('requirements.txt').exists():\n        print(\"\\n=== Scanning requirements.txt ===\")\n        results = scanner.scan_requirements_txt('requirements.txt')\n        total_vulns = sum(len(v) for v in results.values())\n        print(f\"Found {total_vulns} vulnerabilities across {len(results)} packages\")",
      "continuous_monitoring": "import requests\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime\n\ndef monitor_dependencies():\n    \"\"\"Continuously monitor dependencies - FREE!\"\"\"\n    \n    # Load your dependencies\n    dependencies = [\n        {'ecosystem': 'PyPI', 'name': 'django'},\n        {'ecosystem': 'npm', 'name': 'react'},\n        {'ecosystem': 'Go', 'name': 'github.com/gorilla/mux'}\n    ]\n    \n    seen_vulns = set()\n    \n    while True:\n        print(f\"\\n[{datetime.now().strftime('%Y-%m-%d %H:%M')}] Checking for new vulnerabilities...\")\n        \n        for dep in dependencies:\n            payload = {'package': dep}\n            response = requests.post('https://api.osv.dev/v1/query', json=payload)\n            \n            if response.status_code == 200:\n                vulns = response.json().get('vulns', [])\n                \n                for vuln in vulns:\n                    vuln_id = vuln['id']\n                    if vuln_id not in seen_vulns:\n                        seen_vulns.add(vuln_id)\n                        print(f\"\\n\ud83d\udea8 NEW VULNERABILITY: {vuln_id}\")\n                        print(f\"   Package: {dep['ecosystem']}:{dep['name']}\")\n                        print(f\"   Summary: {vuln.get('summary', 'N/A')}\")\n                        print(f\"   Severity: {vuln.get('database_specific', {}).get('severity', 'Unknown')}\")\n        \n        # Check every hour (no rate limits!)\n        time.sleep(3600)\n\n# Run continuous monitoring\n# monitor_dependencies()"
    }
  },
  "metadata": {
    "last_updated": "2024-01-15",
    "license": "Data is free to use",
    "maintainer": "Google Open Source Security Team"
  },
  "name": "OSV - Open Source Vulnerabilities",
  "operational_guidance": {
    "best_practices": [
      "No authentication needed - just start using!",
      "Use batch queries for efficiency",
      "Download databases for offline/airgapped systems",
      "Integrate into CI/CD pipelines",
      "Monitor continuously - no rate limits!"
    ],
    "recommended_update_frequency": "Real-time or hourly for critical systems",
    "use_cases": [
      "Dependency scanning in CI/CD",
      "Real-time vulnerability monitoring",
      "Security audits",
      "Supply chain analysis",
      "Offline vulnerability scanning",
      "Research and statistics"
    ],
    "value_proposition": "Completely FREE unified vulnerability database with NO rate limits, covering all major ecosystems"
  },
  "quality_metrics": {
    "cost": "COMPLETELY FREE",
    "data_quality": "High - aggregated from authoritative sources",
    "rate_limits": "NONE - No limits whatsoever!",
    "reliability": "Excellent - Google infrastructure",
    "unique_features": [
      "Unified schema across ecosystems",
      "Git commit scanning",
      "Batch queries",
      "Version range analysis",
      "Database downloads for offline use"
    ]
  },
  "subcategory": "aggregated",
  "url": "https://osv.dev"
}
