{
  "id": "osv-dev",
  "name": "OSV - Open Source Vulnerabilities",
  "description": "Google's unified vulnerability database providing FREE access to security vulnerabilities from multiple sources. Aggregates data from GitHub, PyPI, npm, Go, Rust, Linux kernel, and more. Completely free with no rate limits!",
  "category": "vulnerability",
  "subcategory": "aggregated",
  "website": "https://osv.dev",
  "documentation": "https://google.github.io/osv.dev/api/",
  
  "api": {
    "type": "REST",
    "base_url": "https://api.osv.dev/v1",
    "endpoints": [
      {
        "path": "/query",
        "method": "POST",
        "description": "Query for vulnerabilities - COMPLETELY FREE!",
        "parameters": [
          {
            "name": "package",
            "type": "object",
            "required": false,
            "description": "Package to query",
            "example": {"ecosystem": "PyPI", "name": "django"}
          },
          {
            "name": "version",
            "type": "string",
            "required": false,
            "description": "Package version",
            "example": "3.2.0"
          },
          {
            "name": "commit",
            "type": "string",
            "required": false,
            "description": "Git commit hash",
            "example": "6879efc2c1596d11a6a6ad296f80063b558d5e0f"
          },
          {
            "name": "page_token",
            "type": "string",
            "required": false,
            "description": "Pagination token"
          }
        ],
        "request_body": {
          "type": "JSON",
          "example": {
            "package": {
              "ecosystem": "npm",
              "name": "express"
            },
            "version": "4.17.1"
          }
        },
        "response_format": {
          "type": "JSON",
          "example": {
            "vulns": [
              {
                "id": "GHSA-xxxx-xxxx-xxxx",
                "summary": "Vulnerability summary",
                "details": "Detailed description",
                "aliases": ["CVE-2021-xxxxx"],
                "modified": "2024-01-15T00:00:00Z",
                "database_specific": {
                  "severity": "HIGH"
                }
              }
            ]
          }
        },
        "rate_limit": {
          "notes": "NO RATE LIMITS! Completely free to use without authentication!"
        }
      },
      {
        "path": "/vulns/{id}",
        "method": "GET",
        "description": "Get vulnerability details - FREE!",
        "parameters": [
          {
            "name": "id",
            "type": "string",
            "required": true,
            "description": "Vulnerability ID",
            "example": "GHSA-2qrg-x229-3v8q"
          }
        ]
      },
      {
        "path": "/query_affected",
        "method": "POST",
        "description": "Batch query for affected versions - FREE!",
        "request_body": {
          "type": "JSON",
          "example": {
            "queries": [
              {
                "package": {
                  "ecosystem": "PyPI",
                  "name": "requests"
                },
                "version": "2.25.0"
              },
              {
                "package": {
                  "ecosystem": "npm",
                  "name": "lodash"
                },
                "version": "4.17.20"
              }
            ]
          }
        }
      },
      {
        "path": "/querybatch",
        "method": "POST",
        "description": "Batch vulnerability query - FREE!",
        "request_body": {
          "type": "JSON",
          "example": {
            "queries": [
              {
                "package": {
                  "ecosystem": "Go",
                  "name": "github.com/gorilla/websocket"
                }
              }
            ]
          }
        }
      }
    ],
    "ecosystems": [
      "PyPI",
      "npm",
      "Go",
      "Packagist",
      "Maven",
      "NuGet",
      "RubyGems",
      "crates.io",
      "Hex",
      "Pub",
      "ConanCenter",
      "Linux",
      "OSS-Fuzz",
      "GitHub Actions",
      "Android"
    ]
  },
  
  "authentication": {
    "type": "none",
    "required": false,
    "notes": "OSV is COMPLETELY FREE with NO AUTHENTICATION required! No API keys, no rate limits, no registration. Just start using it!"
  },
  
  "integration_examples": {
    "python": {
      "basic_query": "import requests\nimport json\n\n# Query for vulnerabilities - COMPLETELY FREE!\nurl = 'https://api.osv.dev/v1/query'\n\n# Check a Python package\npayload = {\n    'package': {\n        'ecosystem': 'PyPI',\n        'name': 'django'\n    },\n    'version': '3.2.0'\n}\n\nresponse = requests.post(url, json=payload)\nvulns = response.json().get('vulns', [])\n\nprint(f\"Found {len(vulns)} vulnerabilities (FREE API!)\\n\")\n\nfor vuln in vulns:\n    print(f\"ðŸ”´ {vuln['id']}\")\n    print(f\"   Summary: {vuln.get('summary', 'N/A')}\")\n    print(f\"   Severity: {vuln.get('database_specific', {}).get('severity', 'Unknown')}\")\n    print(f\"   Aliases: {', '.join(vuln.get('aliases', []))}\")\n    print()",
      
      "comprehensive_scanner": "#!/usr/bin/env python3\n\"\"\"\nOSV.dev Vulnerability Scanner - COMPLETELY FREE!\nNo API key or rate limits - scan all your dependencies!\n\"\"\"\n\nimport requests\nimport json\nimport subprocess\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nclass OSVScanner:\n    def __init__(self):\n        self.base_url = 'https://api.osv.dev/v1'\n    \n    def scan_package(self, ecosystem: str, name: str, version: str = None) -> List[Dict]:\n        \"\"\"Scan a package for vulnerabilities - FREE!\"\"\"\n        \n        payload = {\n            'package': {\n                'ecosystem': ecosystem,\n                'name': name\n            }\n        }\n        \n        if version:\n            payload['version'] = version\n        \n        response = requests.post(f'{self.base_url}/query', json=payload)\n        \n        if response.status_code == 200:\n            return response.json().get('vulns', [])\n        return []\n    \n    def get_vulnerability(self, vuln_id: str) -> Dict:\n        \"\"\"Get detailed vulnerability info - FREE!\"\"\"\n        \n        response = requests.get(f'{self.base_url}/vulns/{vuln_id}')\n        \n        if response.status_code == 200:\n            return response.json()\n        return {}\n    \n    def batch_scan(self, packages: List[Dict]) -> Dict[str, List]:\n        \"\"\"Scan multiple packages at once - FREE!\"\"\"\n        \n        queries = []\n        for pkg in packages:\n            query = {'package': {\n                'ecosystem': pkg['ecosystem'],\n                'name': pkg['name']\n            }}\n            if 'version' in pkg:\n                query['version'] = pkg['version']\n            queries.append(query)\n        \n        payload = {'queries': queries}\n        response = requests.post(f'{self.base_url}/querybatch', json=payload)\n        \n        results = {}\n        if response.status_code == 200:\n            data = response.json()\n            for i, result in enumerate(data.get('results', [])):\n                pkg_key = f\"{packages[i]['ecosystem']}:{packages[i]['name']}\"\n                results[pkg_key] = result.get('vulns', [])\n        \n        return results\n    \n    def scan_requirements_txt(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Python requirements.txt - FREE!\"\"\"\n        \n        packages = []\n        with open(file_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    # Parse package name and version\n                    if '==' in line:\n                        name, version = line.split('==')\n                        packages.append({\n                            'ecosystem': 'PyPI',\n                            'name': name.strip(),\n                            'version': version.strip()\n                        })\n                    elif '>=' in line or '<=' in line or '~=' in line:\n                        name = line.split('[')[0].split('<')[0].split('>')[0].split('~')[0]\n                        packages.append({\n                            'ecosystem': 'PyPI',\n                            'name': name.strip()\n                        })\n        \n        return self.batch_scan(packages)\n    \n    def scan_package_json(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Node.js package.json - FREE!\"\"\"\n        \n        with open(file_path, 'r') as f:\n            data = json.load(f)\n        \n        packages = []\n        \n        # Scan dependencies\n        for name, version in data.get('dependencies', {}).items():\n            # Clean version string\n            version = version.lstrip('^~')\n            packages.append({\n                'ecosystem': 'npm',\n                'name': name,\n                'version': version if version[0].isdigit() else None\n            })\n        \n        # Scan devDependencies\n        for name, version in data.get('devDependencies', {}).items():\n            version = version.lstrip('^~')\n            packages.append({\n                'ecosystem': 'npm',\n                'name': name,\n                'version': version if version[0].isdigit() else None\n            })\n        \n        return self.batch_scan(packages)\n    \n    def scan_go_mod(self, file_path: str) -> Dict[str, List]:\n        \"\"\"Scan Go modules - FREE!\"\"\"\n        \n        packages = []\n        with open(file_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith('require') or '\\t' in line:\n                    parts = line.split()\n                    if len(parts) >= 2 and '.' in parts[0]:\n                        name = parts[0]\n                        version = parts[1] if len(parts) > 1 else None\n                        packages.append({\n                            'ecosystem': 'Go',\n                            'name': name,\n                            'version': version\n                        })\n        \n        return self.batch_scan(packages)\n    \n    def scan_git_commit(self, commit_hash: str) -> List[Dict]:\n        \"\"\"Scan a Git commit for vulnerabilities - FREE!\"\"\"\n        \n        payload = {'commit': commit_hash}\n        response = requests.post(f'{self.base_url}/query', json=payload)\n        \n        if response.status_code == 200:\n            return response.json().get('vulns', [])\n        return []\n    \n    def format_vulnerability(self, vuln: Dict) -> str:\n        \"\"\"Format vulnerability for display\"\"\"\n        \n        severity = vuln.get('database_specific', {}).get('severity', 'UNKNOWN')\n        severity_emoji = {\n            'CRITICAL': 'ðŸ”´',\n            'HIGH': 'ðŸŸ ',\n            'MODERATE': 'ðŸŸ¡',\n            'MEDIUM': 'ðŸŸ¡',\n            'LOW': 'ðŸŸ¢'\n        }.get(severity.upper(), 'âšª')\n        \n        output = f\"{severity_emoji} {vuln['id']}\\n\"\n        output += f\"   Summary: {vuln.get('summary', 'N/A')}\\n\"\n        output += f\"   Severity: {severity}\\n\"\n        \n        if vuln.get('aliases'):\n            output += f\"   Aliases: {', '.join(vuln['aliases'])}\\n\"\n        \n        if vuln.get('affected'):\n            for affected in vuln['affected']:\n                if affected.get('ranges'):\n                    output += f\"   Affected: {affected['ranges'][0].get('type', 'version')} \"\n                    events = affected['ranges'][0].get('events', [])\n                    if events:\n                        output += f\"{events[0].get('introduced', '')} - {events[-1].get('fixed', 'latest')}\\n\"\n        \n        return output\n\n# Example usage - ALL FREE!\nif __name__ == '__main__':\n    scanner = OSVScanner()\n    \n    # Scan a single package\n    print(\"\\n=== Scanning Django (FREE) ===\")\n    vulns = scanner.scan_package('PyPI', 'django', '3.2.0')\n    for vuln in vulns:\n        print(scanner.format_vulnerability(vuln))\n    \n    # Batch scan multiple packages\n    print(\"\\n=== Batch Scanning Popular Packages ===\")\n    packages = [\n        {'ecosystem': 'npm', 'name': 'express', 'version': '4.17.1'},\n        {'ecosystem': 'PyPI', 'name': 'requests', 'version': '2.25.0'},\n        {'ecosystem': 'Go', 'name': 'github.com/gin-gonic/gin', 'version': 'v1.7.0'}\n    ]\n    \n    results = scanner.batch_scan(packages)\n    for pkg_name, vulns in results.items():\n        if vulns:\n            print(f\"\\n{pkg_name}: {len(vulns)} vulnerabilities found\")\n            for vuln in vulns[:2]:  # Show first 2\n                print(f\"  - {vuln['id']}: {vuln.get('summary', 'N/A')[:80]}\")\n    \n    # Scan local project files\n    if Path('requirements.txt').exists():\n        print(\"\\n=== Scanning requirements.txt ===\")\n        results = scanner.scan_requirements_txt('requirements.txt')\n        total_vulns = sum(len(v) for v in results.values())\n        print(f\"Found {total_vulns} vulnerabilities across {len(results)} packages\")",
      
      "continuous_monitoring": "import requests\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime\n\ndef monitor_dependencies():\n    \"\"\"Continuously monitor dependencies - FREE!\"\"\"\n    \n    # Load your dependencies\n    dependencies = [\n        {'ecosystem': 'PyPI', 'name': 'django'},\n        {'ecosystem': 'npm', 'name': 'react'},\n        {'ecosystem': 'Go', 'name': 'github.com/gorilla/mux'}\n    ]\n    \n    seen_vulns = set()\n    \n    while True:\n        print(f\"\\n[{datetime.now().strftime('%Y-%m-%d %H:%M')}] Checking for new vulnerabilities...\")\n        \n        for dep in dependencies:\n            payload = {'package': dep}\n            response = requests.post('https://api.osv.dev/v1/query', json=payload)\n            \n            if response.status_code == 200:\n                vulns = response.json().get('vulns', [])\n                \n                for vuln in vulns:\n                    vuln_id = vuln['id']\n                    if vuln_id not in seen_vulns:\n                        seen_vulns.add(vuln_id)\n                        print(f\"\\nðŸš¨ NEW VULNERABILITY: {vuln_id}\")\n                        print(f\"   Package: {dep['ecosystem']}:{dep['name']}\")\n                        print(f\"   Summary: {vuln.get('summary', 'N/A')}\")\n                        print(f\"   Severity: {vuln.get('database_specific', {}).get('severity', 'Unknown')}\")\n        \n        # Check every hour (no rate limits!)\n        time.sleep(3600)\n\n# Run continuous monitoring\n# monitor_dependencies()"
    },
    
    "curl": {
      "query_package": "# Query package vulnerabilities - FREE!\ncurl -X POST 'https://api.osv.dev/v1/query' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"package\": {\"ecosystem\": \"PyPI\", \"name\": \"django\"}, \"version\": \"3.2.0\"}'",
      
      "get_vulnerability": "# Get vulnerability details - FREE!\ncurl 'https://api.osv.dev/v1/vulns/GHSA-2qrg-x229-3v8q'",
      
      "batch_query": "# Batch query multiple packages - FREE!\ncurl -X POST 'https://api.osv.dev/v1/querybatch' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"queries\": [{\"package\": {\"ecosystem\": \"npm\", \"name\": \"express\"}}, {\"package\": {\"ecosystem\": \"PyPI\", \"name\": \"flask\"}}]}'",
      
      "query_git_commit": "# Query vulnerabilities by git commit - FREE!\ncurl -X POST 'https://api.osv.dev/v1/query' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"commit\": \"6879efc2c1596d11a6a6ad296f80063b558d5e0f\"}'",
      
      "download_database": "# Download entire OSV database - FREE!\n# Each ecosystem has its own downloadable database\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/PyPI/all.zip'\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/npm/all.zip'\ncurl -O 'https://osv-vulnerabilities.storage.googleapis.com/Go/all.zip'"
    },
    
    "javascript": {
      "client": "// OSV.dev JavaScript Client - COMPLETELY FREE!\nclass OSVClient {\n  constructor() {\n    this.baseUrl = 'https://api.osv.dev/v1';\n  }\n  \n  async queryPackage(ecosystem, name, version = null) {\n    const payload = {\n      package: { ecosystem, name }\n    };\n    \n    if (version) {\n      payload.version = version;\n    }\n    \n    const response = await fetch(`${this.baseUrl}/query`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    });\n    \n    const data = await response.json();\n    return data.vulns || [];\n  }\n  \n  async getVulnerability(id) {\n    const response = await fetch(`${this.baseUrl}/vulns/${id}`);\n    return response.json();\n  }\n  \n  async batchQuery(packages) {\n    const queries = packages.map(pkg => ({\n      package: {\n        ecosystem: pkg.ecosystem,\n        name: pkg.name\n      },\n      ...(pkg.version && { version: pkg.version })\n    }));\n    \n    const response = await fetch(`${this.baseUrl}/querybatch`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ queries })\n    });\n    \n    const data = await response.json();\n    return data.results || [];\n  }\n  \n  async scanPackageJson(packageJson) {\n    const packages = [];\n    \n    // Add dependencies\n    for (const [name, version] of Object.entries(packageJson.dependencies || {})) {\n      packages.push({\n        ecosystem: 'npm',\n        name,\n        version: version.replace(/[^0-9.]/g, '')\n      });\n    }\n    \n    // Add devDependencies\n    for (const [name, version] of Object.entries(packageJson.devDependencies || {})) {\n      packages.push({\n        ecosystem: 'npm',\n        name,\n        version: version.replace(/[^0-9.]/g, '')\n      });\n    }\n    \n    return this.batchQuery(packages);\n  }\n}\n\n// Usage - ALL FREE!\nconst client = new OSVClient();\n\n// Check a single package\nclient.queryPackage('npm', 'express', '4.17.1').then(vulns => {\n  console.log(`Found ${vulns.length} vulnerabilities`);\n  vulns.forEach(v => {\n    console.log(`- ${v.id}: ${v.summary}`);\n  });\n});\n\n// Batch check multiple packages\nconst packages = [\n  { ecosystem: 'npm', name: 'lodash', version: '4.17.20' },\n  { ecosystem: 'PyPI', name: 'requests', version: '2.25.0' }\n];\n\nclient.batchQuery(packages).then(results => {\n  results.forEach((result, i) => {\n    const pkg = packages[i];\n    console.log(`\\n${pkg.ecosystem}:${pkg.name}@${pkg.version}`);\n    console.log(`Vulnerabilities: ${result.vulns?.length || 0}`);\n  });\n});"
    }
  },
  
  "data_format": {
    "primary_format": "JSON",
    "encoding": "UTF-8",
    "schemas": {
      "osv_schema": "https://ossf.github.io/osv-schema/",
      "documentation": "https://google.github.io/osv.dev/data/"
    },
    "field_descriptions": {
      "id": "Unique vulnerability identifier",
      "summary": "One-line summary",
      "details": "Detailed description",
      "aliases": "Other identifiers (CVE, GHSA, etc.)",
      "modified": "Last modification time",
      "published": "Publication time",
      "withdrawn": "Withdrawal time if retracted",
      "severity": "CVSS score and severity level",
      "affected": "Affected package versions and ranges",
      "references": "URLs with more information",
      "credits": "Reporters and contributors"
    }
  },
  
  "coverage": {
    "data_sources": [
      "GitHub Advisory Database",
      "PyPI Advisory Database",
      "Go Vulnerability Database",
      "Rust Advisory Database",
      "npm Security Advisories",
      "Linux Kernel CVEs",
      "OSS-Fuzz",
      "RubyGems Advisory Database",
      "Packagist Security Advisories",
      "PYSEC",
      "Android Security Bulletins",
      "Debian Security Tracker"
    ],
    "ecosystems": "15+ programming language ecosystems",
    "volume": "50,000+ vulnerabilities and growing",
    "update_frequency": "Real-time as sources update"
  },
  
  "quality_metrics": {
    "cost": "COMPLETELY FREE",
    "rate_limits": "NONE - No limits whatsoever!",
    "reliability": "Excellent - Google infrastructure",
    "data_quality": "High - aggregated from authoritative sources",
    "unique_features": [
      "Unified schema across ecosystems",
      "Git commit scanning",
      "Batch queries",
      "Version range analysis",
      "Database downloads for offline use"
    ]
  },
  
  "operational_guidance": {
    "recommended_update_frequency": "Real-time or hourly for critical systems",
    "best_practices": [
      "No authentication needed - just start using!",
      "Use batch queries for efficiency",
      "Download databases for offline/airgapped systems",
      "Integrate into CI/CD pipelines",
      "Monitor continuously - no rate limits!"
    ],
    "value_proposition": "Completely FREE unified vulnerability database with NO rate limits, covering all major ecosystems",
    "use_cases": [
      "Dependency scanning in CI/CD",
      "Real-time vulnerability monitoring",
      "Security audits",
      "Supply chain analysis",
      "Offline vulnerability scanning",
      "Research and statistics"
    ]
  },
  
  "metadata": {
    "last_updated": "2024-01-15",
    "maintainer": "Google Open Source Security Team",
    "license": "Data is free to use"
  }
}