{
  "api": {
    "alternative_sources": [
      {
        "access": "free",
        "description": "Free vulnerability scanning for public repositories",
        "name": "Docker Hub Vulnerability Scanning",
        "type": "Web Interface",
        "url": "https://hub.docker.com"
      },
      {
        "access": "free",
        "name": "Docker Security Best Practices",
        "type": "Documentation",
        "url": "https://docs.docker.com/engine/security/"
      },
      {
        "access": "free",
        "name": "CVE Details for Docker",
        "type": "CVE Database",
        "url": "https://www.cvedetails.com/vendor/13534/Docker.html"
      }
    ],
    "base_url": "https://api.github.com",
    "endpoints": [
      {
        "description": "Get published Docker security advisories",
        "method": "GET",
        "parameters": [
          {
            "description": "Advisory state: published, withdrawn",
            "example": "published",
            "name": "state",
            "required": false,
            "type": "string"
          },
          {
            "description": "Results per page (max 100)",
            "example": "100",
            "name": "per_page",
            "required": false,
            "type": "integer"
          }
        ],
        "path": "/repos/docker/docker/security-advisories",
        "rate_limit": "60 req/hour without auth, 5000 with token"
      },
      {
        "description": "Search for security-related Docker issues",
        "method": "GET",
        "parameters": [
          {
            "description": "Filter by security labels",
            "example": "kind/security,area/security",
            "name": "labels",
            "required": false,
            "type": "string"
          },
          {
            "description": "Issue state",
            "example": "all",
            "name": "state",
            "required": false,
            "type": "string"
          }
        ],
        "path": "/repos/docker/docker/issues"
      },
      {
        "description": "Docker Official Images security issues",
        "method": "GET",
        "parameters": [
          {
            "description": "Security-related labels",
            "example": "security",
            "name": "labels",
            "required": false,
            "type": "string"
          }
        ],
        "path": "/repos/docker/official-images/issues"
      }
    ],
    "rate_limit": {
      "notes": "GitHub API rate limits apply",
      "requests_per_hour_no_auth": 60,
      "requests_per_hour_with_token": 5000
    },
    "type": "REST"
  },
  "authentication": {
    "notes": "COMPLETELY FREE! Docker security advisories accessible via GitHub API, Docker Hub API, and RSS feeds without authentication. Optional Docker Hub token increases rate limits.",
    "required": false,
    "type": "none"
  },
  "authority": 96,
  "category": "container-security",
  "coverage": 88,
  "data_coverage": {
    "content_types": [
      "Docker Engine vulnerabilities",
      "Container runtime security issues",
      "Docker official image vulnerabilities",
      "Container escape vulnerabilities",
      "Security best practices updates",
      "CVE details and CVSS scores",
      "Security patches and fixes",
      "Vulnerability disclosure timelines"
    ],
    "docker_components": [
      "Docker Engine",
      "Docker Desktop",
      "Docker CLI",
      "containerd",
      "runc",
      "Docker Compose",
      "Docker Swarm",
      "Docker Build",
      "Docker Registry",
      "Official Images"
    ],
    "temporal": {
      "historical_data": "2013-present",
      "latency": "Immediate upon publication",
      "update_frequency": "Real-time for new disclosures"
    },
    "vulnerability_types": [
      "Container escape",
      "Privilege escalation",
      "Image vulnerabilities",
      "Network security",
      "Secrets management",
      "Supply chain attacks",
      "Registry security",
      "Runtime vulnerabilities"
    ]
  },
  "description": "Docker security advisories, vulnerability information, and container security best practices provided FREE through GitHub, Docker Hub, and official Docker security communications.",
  "documentation": "https://docs.docker.com/engine/security/",
  "format": "json",
  "id": "docker-security",
  "integration_examples": {
    "curl": {
      "check_official_images": "# Check Docker official images for security updates\ncurl -s 'https://api.github.com/repos/docker/official-images/issues?labels=security&per_page=5' | jq '.[] | {number, title, created_at}'",
      "get_docker_advisories": "# Get Docker security advisories - COMPLETELY FREE!\ncurl -s 'https://api.github.com/repos/docker/docker/security-advisories?state=published&per_page=10' | jq '.[] | {ghsa_id, cve_id, summary, severity, published_at}'",
      "get_recent_releases": "# Get recent Docker releases with security info\ncurl -s 'https://api.github.com/repos/docker/docker/releases?per_page=5' | jq '.[] | {tag_name, published_at, body}' | head -20",
      "search_security_issues": "# Search for security-related Docker issues\ncurl -s 'https://api.github.com/repos/docker/docker/issues?labels=kind/security&state=all&per_page=5' | jq '.[] | {number, title, state, created_at}'"
    },
    "javascript": {
      "docker_vulnerability_tracker": "// Track Docker vulnerabilities by version - FREE!\nconst axios = require('axios');\nconst fs = require('fs');\nconst semver = require('semver'); // npm install semver\n\nclass DockerVulnTracker {\n  constructor(dockerVersions, githubToken) {\n    this.dockerVersions = dockerVersions || [];\n    this.baseUrl = 'https://api.github.com/repos/docker/docker';\n    this.headers = githubToken ? { 'Authorization': `token ${githubToken}` } : {};\n    this.cacheFile = 'docker_vulns.json';\n  }\n  \n  async getSecurityAdvisories() {\n    try {\n      const response = await axios.get(\n        `${this.baseUrl}/security-advisories`,\n        {\n          headers: this.headers,\n          params: {\n            state: 'published',\n            per_page: 100\n          }\n        }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching advisories:', error.message);\n      return [];\n    }\n  }\n  \n  isVersionAffected(vulnerableRange, dockerVersion) {\n    try {\n      // Simplified version checking\n      // Real implementation would need more sophisticated parsing\n      if (vulnerableRange.includes('>=') && vulnerableRange.includes('<')) {\n        const matches = vulnerableRange.match(/>= ([\\d\\.]+).*< ([\\d\\.]+)/);\n        if (matches) {\n          const minVersion = matches[1];\n          const maxVersion = matches[2];\n          return semver.gte(dockerVersion, minVersion) && semver.lt(dockerVersion, maxVersion);\n        }\n      }\n      \n      // Fallback to simple string matching\n      return vulnerableRange.includes(dockerVersion.split('.').slice(0, 2).join('.'));\n    } catch {\n      return false;\n    }\n  }\n  \n  analyzeDockerVulnerabilities() {\n    return new Promise(async (resolve) => {\n      console.log(`\ud83d\udd0d Analyzing Docker vulnerabilities (FREE!)\\n`);\n      \n      const advisories = await this.getSecurityAdvisories();\n      const affectedAdvisories = [];\n      const allAdvisories = [];\n      \n      for (const advisory of advisories) {\n        const vulnInfo = {\n          ghsa_id: advisory.ghsa_id,\n          cve_id: advisory.cve_id,\n          summary: advisory.summary,\n          severity: advisory.severity,\n          cvss_score: advisory.cvss?.score || 0,\n          published_at: advisory.published_at,\n          html_url: advisory.html_url,\n          affects_versions: [],\n          vulnerable_ranges: [],\n          patched_versions: []\n        };\n        \n        // Check if this advisory affects our Docker versions\n        if (advisory.vulnerabilities) {\n          for (const vuln of advisory.vulnerabilities) {\n            if (vuln.vulnerable_version_range) {\n              vulnInfo.vulnerable_ranges.push(vuln.vulnerable_version_range);\n              \n              for (const version of this.dockerVersions) {\n                if (this.isVersionAffected(vuln.vulnerable_version_range, version)) {\n                  vulnInfo.affects_versions.push(version);\n                }\n              }\n            }\n            \n            if (vuln.patched_versions) {\n              vulnInfo.patched_versions = vulnInfo.patched_versions.concat(vuln.patched_versions);\n            }\n          }\n        }\n        \n        allAdvisories.push(vulnInfo);\n        \n        if (vulnInfo.affects_versions.length > 0) {\n          affectedAdvisories.push(vulnInfo);\n        }\n      }\n      \n      // Generate report\n      this.generateVulnerabilityReport(affectedAdvisories, allAdvisories);\n      \n      // Cache results\n      fs.writeFileSync(this.cacheFile, JSON.stringify({\n        docker_versions: this.dockerVersions,\n        scan_date: new Date().toISOString(),\n        affected_advisories: affectedAdvisories,\n        total_advisories: allAdvisories.length\n      }, null, 2));\n      \n      resolve({ affected: affectedAdvisories, total: allAdvisories });\n    });\n  }\n  \n  generateVulnerabilityReport(affectedAdvisories, allAdvisories) {\n    console.log('\ud83d\udcca Docker Vulnerability Analysis Results:\\n');\n    console.log(`Total Docker advisories: ${allAdvisories.length}`);\n    console.log(`Advisories affecting your versions: ${affectedAdvisories.length}\\n`);\n    \n    if (affectedAdvisories.length === 0) {\n      console.log('\u2705 No known vulnerabilities affect your Docker versions!');\n      return;\n    }\n    \n    console.log('\u26a0\ufe0f  Vulnerabilities affecting your Docker installations:\\n');\n    \n    // Sort by severity and CVSS score\n    const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };\n    affectedAdvisories.sort((a, b) => {\n      const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];\n      if (severityDiff !== 0) return severityDiff;\n      return b.cvss_score - a.cvss_score;\n    });\n    \n    affectedAdvisories.forEach(advisory => {\n      const severityIcon = {\n        'critical': '\ud83d\udd34',\n        'high': '\ud83d\udfe0', \n        'medium': '\ud83d\udfe1',\n        'low': '\ud83d\udfe2'\n      }[advisory.severity] || '\u26aa';\n      \n      console.log(`${severityIcon} ${advisory.summary}`);\n      console.log(`   \ud83d\udccb GHSA: ${advisory.ghsa_id}`);\n      \n      if (advisory.cve_id) {\n        console.log(`   \ud83c\udd94 CVE: ${advisory.cve_id}`);\n      }\n      \n      console.log(`   \ud83d\udcca Severity: ${advisory.severity.toUpperCase()}`);\n      \n      if (advisory.cvss_score > 0) {\n        console.log(`   \ud83d\udcc8 CVSS: ${advisory.cvss_score}/10`);\n      }\n      \n      console.log(`   \ud83c\udfaf Your affected versions: ${advisory.affects_versions.join(', ')}`);\n      \n      if (advisory.vulnerable_ranges.length > 0) {\n        console.log(`   \u26a0\ufe0f  Vulnerable: ${advisory.vulnerable_ranges.join(', ')}`);\n      }\n      \n      if (advisory.patched_versions.length > 0) {\n        console.log(`   \u2705 Patched in: ${advisory.patched_versions.slice(0, 3).join(', ')}`);\n      }\n      \n      console.log(`   \ud83d\udcc5 Published: ${advisory.published_at}`);\n      console.log(`   \ud83d\udd17 ${advisory.html_url}`);\n      console.log();\n    });\n    \n    // Recommendations\n    console.log('\ud83d\udca1 Recommendations:');\n    const criticalCount = affectedAdvisories.filter(a => a.severity === 'critical').length;\n    const highCount = affectedAdvisories.filter(a => a.severity === 'high').length;\n    \n    if (criticalCount > 0) {\n      console.log(`\ud83d\udea8 URGENT: ${criticalCount} critical vulnerabilities require immediate attention`);\n    }\n    \n    if (highCount > 0) {\n      console.log(`\u26a0\ufe0f  HIGH: ${highCount} high-severity vulnerabilities should be addressed soon`);\n    }\n    \n    console.log('\ud83d\udccb Plan Docker upgrades to address these vulnerabilities');\n    console.log('\ud83d\udd0d Review patched versions for upgrade planning');\n  }\n}\n\n// Usage\nconst tracker = new DockerVulnTracker(['20.10.24', '23.0.6', '24.0.2']);\ntracker.analyzeDockerVulnerabilities();",
      "fetch_docker_security": "// Fetch Docker Security Advisories - COMPLETELY FREE!\nconst axios = require('axios');\n\nconst fetchDockerSecurity = async () => {\n  const baseUrl = 'https://api.github.com/repos/docker/docker';\n  \n  // Optional: Add GitHub token for higher rate limits\n  const headers = {\n    // 'Authorization': 'token YOUR_GITHUB_TOKEN'\n  };\n  \n  try {\n    console.log('\ud83d\udc33 Docker Security Advisories (FREE!)\\n');\n    \n    // Get security advisories\n    const advisoriesResponse = await axios.get(\n      `${baseUrl}/security-advisories`,\n      {\n        headers,\n        params: {\n          state: 'published',\n          per_page: 20\n        }\n      }\n    );\n    \n    const advisories = advisoriesResponse.data;\n    console.log(`Found ${advisories.length} published advisories\\n`);\n    \n    advisories.forEach(advisory => {\n      const severityIcon = {\n        'critical': '\ud83d\udd34',\n        'high': '\ud83d\udfe0',\n        'medium': '\ud83d\udfe1',\n        'low': '\ud83d\udfe2'\n      }[advisory.severity] || '\u26aa';\n      \n      console.log(`${severityIcon} ${advisory.summary}`);\n      console.log(`   GHSA: ${advisory.ghsa_id}`);\n      \n      if (advisory.cve_id) {\n        console.log(`   CVE: ${advisory.cve_id}`);\n      }\n      \n      console.log(`   Severity: ${advisory.severity.toUpperCase()}`);\n      \n      if (advisory.cvss && advisory.cvss.score) {\n        console.log(`   CVSS: ${advisory.cvss.score}/10`);\n      }\n      \n      console.log(`   Published: ${advisory.published_at}`);\n      \n      // Extract affected versions\n      if (advisory.vulnerabilities && advisory.vulnerabilities.length > 0) {\n        const vuln = advisory.vulnerabilities[0];\n        if (vuln.vulnerable_version_range) {\n          console.log(`   Affected: ${vuln.vulnerable_version_range}`);\n        }\n        if (vuln.patched_versions && vuln.patched_versions.length > 0) {\n          console.log(`   Patched: ${vuln.patched_versions.join(', ')}`);\n        }\n      }\n      \n      console.log(`   URL: ${advisory.html_url}`);\n      console.log();\n    });\n    \n    // Check rate limit\n    console.log(`Rate limit remaining: ${advisoriesResponse.headers['x-ratelimit-remaining'] || 'Unknown'}`);\n    \n  } catch (error) {\n    console.error('Error fetching Docker security:', error.response?.data || error.message);\n  }\n};\n\nfetchDockerSecurity();"
    },
    "python": {
      "docker_security_monitor": "import requests\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime, timedelta\n\nclass DockerSecurityMonitor:\n    \"\"\"Monitor Docker security advisories - FREE!\"\"\"\n    \n    def __init__(self, github_token=None, docker_versions=None):\n        self.base_url = 'https://api.github.com/repos/docker/docker'\n        self.headers = {}\n        if github_token:\n            self.headers['Authorization'] = f'token {github_token}'\n        \n        self.docker_versions = docker_versions or []\n        self.seen_advisories = set()\n        self.state_file = 'docker_security_monitor.json'\n        self.load_state()\n    \n    def load_state(self):\n        try:\n            with open(self.state_file, 'r') as f:\n                data = json.load(f)\n                self.seen_advisories = set(data['seen'])\n        except FileNotFoundError:\n            pass\n    \n    def save_state(self):\n        with open(self.state_file, 'w') as f:\n            json.dump({'seen': list(self.seen_advisories)}, f)\n    \n    def get_security_advisories(self):\n        \"\"\"Get published security advisories\"\"\"\n        url = f'{self.base_url}/security-advisories'\n        params = {'state': 'published', 'per_page': 100}\n        \n        response = requests.get(url, headers=self.headers, params=params)\n        \n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(f\"Error fetching advisories: {response.status_code}\")\n            return []\n    \n    def check_version_affected(self, advisory, target_version):\n        \"\"\"Check if a specific Docker version is affected\"\"\"\n        if not target_version or not advisory.get('vulnerabilities'):\n            return False\n        \n        for vuln in advisory['vulnerabilities']:\n            if vuln.get('vulnerable_version_range'):\n                # Simplified version checking (real implementation would need semver)\n                version_range = vuln['vulnerable_version_range']\n                if any(v in version_range for v in [target_version, target_version.split('.')[0]]):\n                    return True\n        return False\n    \n    def assess_advisory_impact(self, advisory):\n        \"\"\"Assess the impact of a security advisory\"\"\"\n        impact = {\n            'severity': advisory.get('severity', 'unknown'),\n            'cvss_score': 0,\n            'affects_versions': [],\n            'components': [],\n            'attack_vector': 'unknown'\n        }\n        \n        # Extract CVSS score\n        if advisory.get('cvss') and advisory['cvss'].get('score'):\n            impact['cvss_score'] = advisory['cvss']['score']\n        \n        # Check affected versions\n        for version in self.docker_versions:\n            if self.check_version_affected(advisory, version):\n                impact['affects_versions'].append(version)\n        \n        # Extract affected components from description\n        description = advisory.get('description', '').lower()\n        docker_components = [\n            'docker engine', 'containerd', 'runc', 'docker cli',\n            'docker compose', 'docker build', 'registry'\n        ]\n        \n        for component in docker_components:\n            if component in description:\n                impact['components'].append(component)\n        \n        return impact\n    \n    def check_new_advisories(self):\n        \"\"\"Check for new security advisories\"\"\"\n        advisories = self.get_security_advisories()\n        new_advisories = []\n        \n        for advisory in advisories:\n            advisory_id = advisory['ghsa_id']\n            \n            if advisory_id in self.seen_advisories:\n                continue\n            \n            # Assess impact\n            impact = self.assess_advisory_impact(advisory)\n            \n            new_advisory = {\n                'ghsa_id': advisory_id,\n                'cve_id': advisory.get('cve_id'),\n                'summary': advisory['summary'],\n                'severity': advisory['severity'],\n                'published_at': advisory['published_at'],\n                'html_url': advisory['html_url'],\n                'impact': impact\n            }\n            \n            new_advisories.append(new_advisory)\n            self.seen_advisories.add(advisory_id)\n        \n        if new_advisories:\n            self.save_state()\n        \n        return new_advisories\n    \n    def generate_security_report(self):\n        \"\"\"Generate Docker security report\"\"\"\n        print(f\"\ud83d\udc33 Docker Security Report - {datetime.now().strftime('%Y-%m-%d')} (FREE!)\\n\")\n        \n        if self.docker_versions:\n            print(f\"Monitoring for Docker versions: {', '.join(self.docker_versions)}\\n\")\n        \n        new_advisories = self.check_new_advisories()\n        \n        if not new_advisories:\n            print(\"No new security advisories found.\")\n            return\n        \n        # Sort by severity and CVSS score\n        severity_order = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1}\n        new_advisories.sort(\n            key=lambda x: (severity_order.get(x['severity'], 0), x['impact']['cvss_score']),\n            reverse=True\n        )\n        \n        print(f\"\ud83d\udea8 New Security Advisories ({len(new_advisories)} found):\\n\")\n        \n        for advisory in new_advisories:\n            severity_icon = {\n                'critical': '\ud83d\udd34',\n                'high': '\ud83d\udfe0',\n                'medium': '\ud83d\udfe1',\n                'low': '\ud83d\udfe2'\n            }.get(advisory['severity'], '\u26aa')\n            \n            print(f\"{severity_icon} {advisory['summary']}\")\n            print(f\"   \ud83d\udccb GHSA: {advisory['ghsa_id']}\")\n            \n            if advisory['cve_id']:\n                print(f\"   \ud83c\udd94 CVE: {advisory['cve_id']}\")\n            \n            print(f\"   \ud83d\udcca Severity: {advisory['severity'].upper()}\")\n            \n            if advisory['impact']['cvss_score'] > 0:\n                print(f\"   \ud83d\udcc8 CVSS: {advisory['impact']['cvss_score']}/10\")\n            \n            if advisory['impact']['affects_versions']:\n                print(f\"   \u26a0\ufe0f  AFFECTS YOUR VERSIONS: {', '.join(advisory['impact']['affects_versions'])}\")\n            \n            if advisory['impact']['components']:\n                print(f\"   \ud83c\udfaf Components: {', '.join(advisory['impact']['components'])}\")\n            \n            print(f\"   \ud83d\udcc5 Published: {advisory['published_at']}\")\n            print(f\"   \ud83d\udd17 {advisory['html_url']}\")\n            print()\n\n# Usage examples\n# Monitor without specific versions\nmonitor = DockerSecurityMonitor()\nmonitor.generate_security_report()\n\n# Monitor with specific Docker versions\n# monitor = DockerSecurityMonitor(docker_versions=['20.10.24', '23.0.6'])\n# monitor.generate_security_report()\n\n# Monitor with GitHub token for higher rate limits\n# monitor = DockerSecurityMonitor(github_token='your_token_here', docker_versions=['24.0.2'])\n# monitor.generate_security_report()",
      "fetch_advisories": "import requests\nimport json\nfrom datetime import datetime\n\n# Fetch Docker Security Advisories - COMPLETELY FREE!\nurl = 'https://api.github.com/repos/docker/docker/security-advisories'\n\n# Optional: Add GitHub token for higher rate limits\n# headers = {'Authorization': 'token YOUR_GITHUB_TOKEN'}\nheaders = {}  # Using without auth for demo\n\nparams = {\n    'state': 'published',\n    'per_page': 50\n}\n\nresponse = requests.get(url, headers=headers, params=params)\n\nif response.status_code == 200:\n    advisories = response.json()\n    \n    print(f\"Docker Security Advisories (FREE!) - Found {len(advisories)}\\n\")\n    \n    for advisory in advisories:\n        print(f\"\ud83d\udc33 {advisory['summary']}\")\n        print(f\"   GHSA ID: {advisory['ghsa_id']}\")\n        print(f\"   Severity: {advisory['severity']}\")\n        print(f\"   Published: {advisory['published_at']}\")\n        \n        # Extract CVE information\n        if advisory.get('cve_id'):\n            print(f\"   CVE: {advisory['cve_id']}\")\n        \n        # Extract CVSS score\n        if advisory.get('cvss') and advisory['cvss'].get('score'):\n            print(f\"   CVSS Score: {advisory['cvss']['score']}/10\")\n        \n        # Extract affected versions\n        if advisory.get('vulnerabilities'):\n            for vuln in advisory['vulnerabilities']:\n                if vuln.get('vulnerable_version_range'):\n                    print(f\"   Affected Versions: {vuln['vulnerable_version_range']}\")\n                if vuln.get('patched_versions'):\n                    print(f\"   Patched Versions: {', '.join(vuln['patched_versions'])}\")\n        \n        print(f\"   URL: {advisory['html_url']}\")\n        print()\n\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n    \n# Check rate limit\nprint(f\"Rate limit remaining: {response.headers.get('X-RateLimit-Remaining', 'Unknown')}\")"
    }
  },
  "last_updated": "2025-08-15T23:45:00.000Z",
  "metadata": {
    "alternatives": [
      "kubernetes-cve-feed",
      "snyk-container-security",
      "anchore-vulnerability-db"
    ],
    "last_verified": "2025-08-15",
    "license": "Public information",
    "maintainer": "Docker Security Team",
    "related_resources": [
      "Docker Security Best Practices",
      "CIS Docker Benchmark",
      "NIST Container Security Guide",
      "Docker Official Images Security Policy"
    ]
  },
  "name": "Docker Security Advisories",
  "operational_guidance": {
    "best_practices": [
      "Monitor GitHub security advisories endpoint",
      "Subscribe to Docker security notifications",
      "Cross-reference CVE databases for additional context",
      "Track Docker official image updates for security fixes",
      "Implement automated vulnerability scanning",
      "Map vulnerabilities to your container images"
    ],
    "common_use_cases": [
      "Container vulnerability assessment",
      "Docker security patch management",
      "Compliance reporting for containerized applications",
      "Incident response for container security issues",
      "Risk assessment for Docker deployments",
      "Security awareness for DevOps teams",
      "Container image security validation"
    ],
    "recommended_update_frequency": "Monitor daily for critical vulnerabilities, weekly for general security updates",
    "value_proposition": "Official Docker security vulnerability data completely free via multiple channels"
  },
  "quality_metrics": {
    "accessibility": "No registration required",
    "api_stability": "Stable GitHub API",
    "completeness": "Comprehensive Docker ecosystem coverage",
    "cost": "COMPLETELY FREE",
    "data_quality": "Official Docker security team disclosures",
    "reliability": "excellent",
    "update_speed": "Real-time"
  },
  "quality_score": 92,
  "subcategory": "docker",
  "url": "https://github.com/docker/docs/security"
}
