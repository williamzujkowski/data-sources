{
  "api": {
    "alternative_sources": [
      {
        "access": "free",
        "name": "Kubernetes Security Announcements",
        "type": "Google Group",
        "url": "https://groups.google.com/g/kubernetes-security-announce"
      },
      {
        "access": "free",
        "name": "CVE Details for Kubernetes",
        "type": "CVE Database",
        "url": "https://www.cvedetails.com/vendor/15867/Kubernetes.html"
      }
    ],
    "base_url": "https://api.github.com",
    "endpoints": [
      {
        "description": "Get published security advisories",
        "method": "GET",
        "parameters": [
          {
            "description": "Advisory state: published, withdrawn",
            "example": "published",
            "name": "state",
            "required": false,
            "type": "string"
          },
          {
            "description": "Results per page (max 100)",
            "example": "100",
            "name": "per_page",
            "required": false,
            "type": "integer"
          }
        ],
        "path": "/repos/kubernetes/kubernetes/security-advisories",
        "rate_limit": "60 req/hour without auth, 5000 with token"
      },
      {
        "description": "Search for security-related issues",
        "method": "GET",
        "parameters": [
          {
            "description": "Filter by labels",
            "example": "kind/security,sig/security",
            "name": "labels",
            "required": false,
            "type": "string"
          },
          {
            "description": "Issue state",
            "example": "all",
            "name": "state",
            "required": false,
            "type": "string"
          }
        ],
        "path": "/repos/kubernetes/kubernetes/issues"
      },
      {
        "description": "Get release information with security fixes",
        "method": "GET",
        "parameters": [],
        "path": "/repos/kubernetes/kubernetes/releases"
      }
    ],
    "rate_limit": {
      "notes": "GitHub API rate limits apply",
      "requests_per_hour_no_auth": 60,
      "requests_per_hour_with_token": 5000
    },
    "type": "REST"
  },
  "authentication": {
    "notes": "COMPLETELY FREE! Kubernetes security issues accessible via GitHub API without authentication. Optional GitHub token increases rate limits.",
    "required": false,
    "type": "none"
  },
  "authority": 98,
  "category": "container-security",
  "coverage": 95,
  "data_coverage": {
    "content_types": [
      "Published security advisories",
      "CVE details and CVSS scores",
      "Affected Kubernetes versions",
      "Security patches and fixes",
      "Vulnerability disclosure timelines",
      "Mitigation guidance",
      "Attack vector information",
      "Impact assessments"
    ],
    "kubernetes_components": [
      "API Server",
      "etcd",
      "kubelet",
      "kube-proxy",
      "kubectl",
      "Container Runtime",
      "Network Plugins",
      "Storage Plugins",
      "Admission Controllers",
      "RBAC"
    ],
    "temporal": {
      "historical_data": "2014-present",
      "latency": "Immediate upon publication",
      "update_frequency": "Real-time for new disclosures"
    }
  },
  "description": "Kubernetes security vulnerabilities and CVE information provided FREE through GitHub API and official security advisories. No authentication required for public CVE data.",
  "documentation": "https://kubernetes.io/docs/reference/issues-security/",
  "format": "json",
  "id": "kubernetes-cve-feed",
  "integration_examples": {
    "curl": {
      "check_rate_limit": "# Check GitHub API rate limit\ncurl -s 'https://api.github.com/rate_limit' | jq '.rate'",
      "get_k8s_advisories": "# Get Kubernetes security advisories - COMPLETELY FREE!\ncurl -s 'https://api.github.com/repos/kubernetes/kubernetes/security-advisories?state=published&per_page=10' | jq '.[] | {ghsa_id, cve_id, summary, severity, published_at}'",
      "get_recent_releases": "# Get recent Kubernetes releases with security info\ncurl -s 'https://api.github.com/repos/kubernetes/kubernetes/releases?per_page=5' | jq '.[] | {tag_name, published_at, body}' | head -20",
      "search_security_issues": "# Search for security-related issues\ncurl -s 'https://api.github.com/repos/kubernetes/kubernetes/issues?labels=kind/security&state=all&per_page=5' | jq '.[] | {number, title, state, created_at}'"
    },
    "javascript": {
      "fetch_k8s_cves": "// Fetch Kubernetes CVEs - COMPLETELY FREE!\nconst axios = require('axios');\n\nconst fetchKubernetesCVEs = async () => {\n  const baseUrl = 'https://api.github.com/repos/kubernetes/kubernetes';\n  \n  // Optional: Add GitHub token for higher rate limits\n  const headers = {\n    // 'Authorization': 'token YOUR_GITHUB_TOKEN'\n  };\n  \n  try {\n    console.log('\ud83d\udd12 Kubernetes Security Advisories (FREE!)\\n');\n    \n    // Get security advisories\n    const advisoriesResponse = await axios.get(\n      `${baseUrl}/security-advisories`,\n      {\n        headers,\n        params: {\n          state: 'published',\n          per_page: 20\n        }\n      }\n    );\n    \n    const advisories = advisoriesResponse.data;\n    console.log(`Found ${advisories.length} published advisories\\n`);\n    \n    advisories.forEach(advisory => {\n      const severityIcon = {\n        'critical': '\ud83d\udd34',\n        'high': '\ud83d\udfe0',\n        'medium': '\ud83d\udfe1',\n        'low': '\ud83d\udfe2'\n      }[advisory.severity] || '\u26aa';\n      \n      console.log(`${severityIcon} ${advisory.summary}`);\n      console.log(`   GHSA: ${advisory.ghsa_id}`);\n      \n      if (advisory.cve_id) {\n        console.log(`   CVE: ${advisory.cve_id}`);\n      }\n      \n      console.log(`   Severity: ${advisory.severity.toUpperCase()}`);\n      \n      if (advisory.cvss && advisory.cvss.score) {\n        console.log(`   CVSS: ${advisory.cvss.score}/10`);\n      }\n      \n      console.log(`   Published: ${advisory.published_at}`);\n      \n      // Extract affected versions\n      if (advisory.vulnerabilities && advisory.vulnerabilities.length > 0) {\n        const vuln = advisory.vulnerabilities[0];\n        if (vuln.vulnerable_version_range) {\n          console.log(`   Affected: ${vuln.vulnerable_version_range}`);\n        }\n        if (vuln.patched_versions && vuln.patched_versions.length > 0) {\n          console.log(`   Patched: ${vuln.patched_versions.join(', ')}`);\n        }\n      }\n      \n      console.log(`   URL: ${advisory.html_url}`);\n      console.log();\n    });\n    \n    // Check rate limit\n    console.log(`Rate limit remaining: ${advisoriesResponse.headers['x-ratelimit-remaining'] || 'Unknown'}`);\n    \n  } catch (error) {\n    console.error('Error fetching Kubernetes CVEs:', error.response?.data || error.message);\n  }\n};\n\nfetchKubernetesCVEs();",
      "k8s_vulnerability_tracker": "// Track Kubernetes vulnerabilities by cluster version - FREE!\nconst axios = require('axios');\nconst fs = require('fs');\nconst semver = require('semver'); // npm install semver\n\nclass KubernetesVulnTracker {\n  constructor(clusterVersion, githubToken) {\n    this.clusterVersion = clusterVersion;\n    this.baseUrl = 'https://api.github.com/repos/kubernetes/kubernetes';\n    this.headers = githubToken ? { 'Authorization': `token ${githubToken}` } : {};\n    this.cacheFile = 'k8s_vulns.json';\n  }\n  \n  async getSecurityAdvisories() {\n    try {\n      const response = await axios.get(\n        `${this.baseUrl}/security-advisories`,\n        {\n          headers: this.headers,\n          params: {\n            state: 'published',\n            per_page: 100\n          }\n        }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching advisories:', error.message);\n      return [];\n    }\n  }\n  \n  isVersionAffected(vulnerableRange, clusterVersion) {\n    try {\n      // Simplified version checking\n      // Real implementation would need more sophisticated parsing\n      if (vulnerableRange.includes('>=') && vulnerableRange.includes('<')) {\n        const matches = vulnerableRange.match(/>= ([\\d\\.]+).*< ([\\d\\.]+)/);\n        if (matches) {\n          const minVersion = matches[1];\n          const maxVersion = matches[2];\n          return semver.gte(clusterVersion, minVersion) && semver.lt(clusterVersion, maxVersion);\n        }\n      }\n      \n      // Fallback to simple string matching\n      return vulnerableRange.includes(clusterVersion.split('.').slice(0, 2).join('.'));\n    } catch {\n      return false;\n    }\n  }\n  \n  analyzeClusterVulnerabilities() {\n    return new Promise(async (resolve) => {\n      console.log(`\ud83d\udd0d Analyzing Kubernetes v${this.clusterVersion} vulnerabilities (FREE!)\\n`);\n      \n      const advisories = await this.getSecurityAdvisories();\n      const affectedAdvisories = [];\n      const allAdvisories = [];\n      \n      for (const advisory of advisories) {\n        const vulnInfo = {\n          ghsa_id: advisory.ghsa_id,\n          cve_id: advisory.cve_id,\n          summary: advisory.summary,\n          severity: advisory.severity,\n          cvss_score: advisory.cvss?.score || 0,\n          published_at: advisory.published_at,\n          html_url: advisory.html_url,\n          affects_cluster: false,\n          vulnerable_ranges: [],\n          patched_versions: []\n        };\n        \n        // Check if this advisory affects our cluster\n        if (advisory.vulnerabilities) {\n          for (const vuln of advisory.vulnerabilities) {\n            if (vuln.vulnerable_version_range) {\n              vulnInfo.vulnerable_ranges.push(vuln.vulnerable_version_range);\n              \n              if (this.isVersionAffected(vuln.vulnerable_version_range, this.clusterVersion)) {\n                vulnInfo.affects_cluster = true;\n              }\n            }\n            \n            if (vuln.patched_versions) {\n              vulnInfo.patched_versions = vulnInfo.patched_versions.concat(vuln.patched_versions);\n            }\n          }\n        }\n        \n        allAdvisories.push(vulnInfo);\n        \n        if (vulnInfo.affects_cluster) {\n          affectedAdvisories.push(vulnInfo);\n        }\n      }\n      \n      // Generate report\n      this.generateVulnerabilityReport(affectedAdvisories, allAdvisories);\n      \n      // Cache results\n      fs.writeFileSync(this.cacheFile, JSON.stringify({\n        cluster_version: this.clusterVersion,\n        scan_date: new Date().toISOString(),\n        affected_advisories: affectedAdvisories,\n        total_advisories: allAdvisories.length\n      }, null, 2));\n      \n      resolve({ affected: affectedAdvisories, total: allAdvisories });\n    });\n  }\n  \n  generateVulnerabilityReport(affectedAdvisories, allAdvisories) {\n    console.log('\ud83d\udcca Vulnerability Analysis Results:\\n');\n    console.log(`Total Kubernetes advisories: ${allAdvisories.length}`);\n    console.log(`Advisories affecting v${this.clusterVersion}: ${affectedAdvisories.length}\\n`);\n    \n    if (affectedAdvisories.length === 0) {\n      console.log('\u2705 No known vulnerabilities affect your cluster version!');\n      return;\n    }\n    \n    console.log('\u26a0\ufe0f  Vulnerabilities affecting your cluster:\\n');\n    \n    // Sort by severity and CVSS score\n    const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };\n    affectedAdvisories.sort((a, b) => {\n      const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];\n      if (severityDiff !== 0) return severityDiff;\n      return b.cvss_score - a.cvss_score;\n    });\n    \n    affectedAdvisories.forEach(advisory => {\n      const severityIcon = {\n        'critical': '\ud83d\udd34',\n        'high': '\ud83d\udfe0', \n        'medium': '\ud83d\udfe1',\n        'low': '\ud83d\udfe2'\n      }[advisory.severity] || '\u26aa';\n      \n      console.log(`${severityIcon} ${advisory.summary}`);\n      console.log(`   \ud83d\udccb GHSA: ${advisory.ghsa_id}`);\n      \n      if (advisory.cve_id) {\n        console.log(`   \ud83c\udd94 CVE: ${advisory.cve_id}`);\n      }\n      \n      console.log(`   \ud83d\udcca Severity: ${advisory.severity.toUpperCase()}`);\n      \n      if (advisory.cvss_score > 0) {\n        console.log(`   \ud83d\udcc8 CVSS: ${advisory.cvss_score}/10`);\n      }\n      \n      if (advisory.vulnerable_ranges.length > 0) {\n        console.log(`   \ud83c\udfaf Vulnerable: ${advisory.vulnerable_ranges.join(', ')}`);\n      }\n      \n      if (advisory.patched_versions.length > 0) {\n        console.log(`   \u2705 Patched in: ${advisory.patched_versions.slice(0, 3).join(', ')}`);\n      }\n      \n      console.log(`   \ud83d\udcc5 Published: ${advisory.published_at}`);\n      console.log(`   \ud83d\udd17 ${advisory.html_url}`);\n      console.log();\n    });\n    \n    // Recommendations\n    console.log('\ud83d\udca1 Recommendations:');\n    const criticalCount = affectedAdvisories.filter(a => a.severity === 'critical').length;\n    const highCount = affectedAdvisories.filter(a => a.severity === 'high').length;\n    \n    if (criticalCount > 0) {\n      console.log(`\ud83d\udea8 URGENT: ${criticalCount} critical vulnerabilities require immediate attention`);\n    }\n    \n    if (highCount > 0) {\n      console.log(`\u26a0\ufe0f  HIGH: ${highCount} high-severity vulnerabilities should be addressed soon`);\n    }\n    \n    console.log('\ud83d\udccb Plan cluster upgrade to address these vulnerabilities');\n    console.log('\ud83d\udd0d Review patched versions for upgrade planning');\n  }\n}\n\n// Usage\nconst tracker = new KubernetesVulnTracker('1.28.0');\ntracker.analyzeClusterVulnerabilities();"
    },
    "python": {
      "fetch_advisories": "import requests\nimport json\nfrom datetime import datetime\n\n# Fetch Kubernetes Security Advisories - COMPLETELY FREE!\nurl = 'https://api.github.com/repos/kubernetes/kubernetes/security-advisories'\n\n# Optional: Add GitHub token for higher rate limits\n# headers = {'Authorization': 'token YOUR_GITHUB_TOKEN'}\nheaders = {}  # Using without auth for demo\n\nparams = {\n    'state': 'published',\n    'per_page': 50\n}\n\nresponse = requests.get(url, headers=headers, params=params)\n\nif response.status_code == 200:\n    advisories = response.json()\n    \n    print(f\"Kubernetes Security Advisories (FREE!) - Found {len(advisories)}\\n\")\n    \n    for advisory in advisories:\n        print(f\"\ud83d\udd12 {advisory['summary']}\")\n        print(f\"   GHSA ID: {advisory['ghsa_id']}\")\n        print(f\"   Severity: {advisory['severity']}\")\n        print(f\"   Published: {advisory['published_at']}\")\n        \n        # Extract CVE information\n        if advisory.get('cve_id'):\n            print(f\"   CVE: {advisory['cve_id']}\")\n        \n        # Extract CVSS score\n        if advisory.get('cvss') and advisory['cvss'].get('score'):\n            print(f\"   CVSS Score: {advisory['cvss']['score']}/10\")\n        \n        # Extract affected versions\n        if advisory.get('vulnerabilities'):\n            for vuln in advisory['vulnerabilities']:\n                if vuln.get('vulnerable_version_range'):\n                    print(f\"   Affected Versions: {vuln['vulnerable_version_range']}\")\n                if vuln.get('patched_versions'):\n                    print(f\"   Patched Versions: {', '.join(vuln['patched_versions'])}\")\n        \n        print(f\"   URL: {advisory['html_url']}\")\n        print()\n\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n    \n# Check rate limit\nprint(f\"Rate limit remaining: {response.headers.get('X-RateLimit-Remaining', 'Unknown')}\")",
      "k8s_security_monitor": "import requests\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime, timedelta\n\nclass K8sSecurityMonitor:\n    \"\"\"Monitor Kubernetes security advisories - FREE!\"\"\"\n    \n    def __init__(self, github_token=None, cluster_version=None):\n        self.base_url = 'https://api.github.com/repos/kubernetes/kubernetes'\n        self.headers = {}\n        if github_token:\n            self.headers['Authorization'] = f'token {github_token}'\n        \n        self.cluster_version = cluster_version\n        self.seen_advisories = set()\n        self.state_file = 'k8s_security_monitor.json'\n        self.load_state()\n    \n    def load_state(self):\n        try:\n            with open(self.state_file, 'r') as f:\n                data = json.load(f)\n                self.seen_advisories = set(data['seen'])\n        except FileNotFoundError:\n            pass\n    \n    def save_state(self):\n        with open(self.state_file, 'w') as f:\n            json.dump({'seen': list(self.seen_advisories)}, f)\n    \n    def get_security_advisories(self):\n        \"\"\"Get published security advisories\"\"\"\n        url = f'{self.base_url}/security-advisories'\n        params = {'state': 'published', 'per_page': 100}\n        \n        response = requests.get(url, headers=self.headers, params=params)\n        \n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(f\"Error fetching advisories: {response.status_code}\")\n            return []\n    \n    def check_version_affected(self, advisory, target_version):\n        \"\"\"Check if a specific Kubernetes version is affected\"\"\"\n        if not target_version or not advisory.get('vulnerabilities'):\n            return False\n        \n        for vuln in advisory['vulnerabilities']:\n            if vuln.get('vulnerable_version_range'):\n                # Simplified version checking (real implementation would need semver)\n                version_range = vuln['vulnerable_version_range']\n                if any(v in version_range for v in [target_version, target_version.split('.')[0]]):\n                    return True\n        return False\n    \n    def assess_advisory_impact(self, advisory):\n        \"\"\"Assess the impact of a security advisory\"\"\"\n        impact = {\n            'severity': advisory.get('severity', 'unknown'),\n            'cvss_score': 0,\n            'affects_cluster': False,\n            'components': [],\n            'attack_vector': 'unknown'\n        }\n        \n        # Extract CVSS score\n        if advisory.get('cvss') and advisory['cvss'].get('score'):\n            impact['cvss_score'] = advisory['cvss']['score']\n        \n        # Check if affects our cluster version\n        if self.cluster_version:\n            impact['affects_cluster'] = self.check_version_affected(advisory, self.cluster_version)\n        \n        # Extract affected components from description\n        description = advisory.get('description', '').lower()\n        k8s_components = [\n            'api server', 'apiserver', 'etcd', 'kubelet', 'kube-proxy',\n            'kubectl', 'scheduler', 'controller', 'admission', 'rbac'\n        ]\n        \n        for component in k8s_components:\n            if component in description:\n                impact['components'].append(component)\n        \n        return impact\n    \n    def check_new_advisories(self):\n        \"\"\"Check for new security advisories\"\"\"\n        advisories = self.get_security_advisories()\n        new_advisories = []\n        \n        for advisory in advisories:\n            advisory_id = advisory['ghsa_id']\n            \n            if advisory_id in self.seen_advisories:\n                continue\n            \n            # Assess impact\n            impact = self.assess_advisory_impact(advisory)\n            \n            new_advisory = {\n                'ghsa_id': advisory_id,\n                'cve_id': advisory.get('cve_id'),\n                'summary': advisory['summary'],\n                'severity': advisory['severity'],\n                'published_at': advisory['published_at'],\n                'html_url': advisory['html_url'],\n                'impact': impact\n            }\n            \n            new_advisories.append(new_advisory)\n            self.seen_advisories.add(advisory_id)\n        \n        if new_advisories:\n            self.save_state()\n        \n        return new_advisories\n    \n    def generate_security_report(self):\n        \"\"\"Generate Kubernetes security report\"\"\"\n        print(f\"\ud83d\udd12 Kubernetes Security Report - {datetime.now().strftime('%Y-%m-%d')} (FREE!)\\n\")\n        \n        if self.cluster_version:\n            print(f\"Monitoring for cluster version: {self.cluster_version}\\n\")\n        \n        new_advisories = self.check_new_advisories()\n        \n        if not new_advisories:\n            print(\"No new security advisories found.\")\n            return\n        \n        # Sort by severity and CVSS score\n        severity_order = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1}\n        new_advisories.sort(\n            key=lambda x: (severity_order.get(x['severity'], 0), x['impact']['cvss_score']),\n            reverse=True\n        )\n        \n        print(f\"\ud83d\udea8 New Security Advisories ({len(new_advisories)} found):\\n\")\n        \n        for advisory in new_advisories:\n            severity_icon = {\n                'critical': '\ud83d\udd34',\n                'high': '\ud83d\udfe0',\n                'medium': '\ud83d\udfe1',\n                'low': '\ud83d\udfe2'\n            }.get(advisory['severity'], '\u26aa')\n            \n            print(f\"{severity_icon} {advisory['summary']}\")\n            print(f\"   \ud83d\udccb GHSA: {advisory['ghsa_id']}\")\n            \n            if advisory['cve_id']:\n                print(f\"   \ud83c\udd94 CVE: {advisory['cve_id']}\")\n            \n            print(f\"   \ud83d\udcca Severity: {advisory['severity'].upper()}\")\n            \n            if advisory['impact']['cvss_score'] > 0:\n                print(f\"   \ud83d\udcc8 CVSS: {advisory['impact']['cvss_score']}/10\")\n            \n            if advisory['impact']['affects_cluster']:\n                print(f\"   \u26a0\ufe0f  AFFECTS YOUR CLUSTER (v{self.cluster_version})\")\n            \n            if advisory['impact']['components']:\n                print(f\"   \ud83c\udfaf Components: {', '.join(advisory['impact']['components'])}\")\n            \n            print(f\"   \ud83d\udcc5 Published: {advisory['published_at']}\")\n            print(f\"   \ud83d\udd17 {advisory['html_url']}\")\n            print()\n\n# Usage examples\n# Monitor without cluster version\nmonitor = K8sSecurityMonitor()\nmonitor.generate_security_report()\n\n# Monitor with specific cluster version\n# monitor = K8sSecurityMonitor(cluster_version='1.28.0')\n# monitor.generate_security_report()\n\n# Monitor with GitHub token for higher rate limits\n# monitor = K8sSecurityMonitor(github_token='your_token_here', cluster_version='1.28.0')\n# monitor.generate_security_report()"
    }
  },
  "last_updated": "2025-08-15T23:30:00.000Z",
  "metadata": {
    "alternatives": [
      "cve-details-kubernetes",
      "nvd-kubernetes-cves",
      "snyk-kubernetes-advisories"
    ],
    "last_verified": "2025-08-15",
    "license": "Public information",
    "maintainer": "Kubernetes Security Team",
    "related_resources": [
      "Kubernetes Security Announcements Mailing List",
      "CNCF Security SIG",
      "Kubernetes Hardening Guide",
      "CIS Kubernetes Benchmark"
    ]
  },
  "name": "Kubernetes CVE Feed",
  "operational_guidance": {
    "best_practices": [
      "Monitor GitHub security advisories endpoint",
      "Subscribe to kubernetes-security-announce mailing list",
      "Cross-reference CVE databases for additional context",
      "Track Kubernetes release notes for security fixes",
      "Implement automated vulnerability scanning",
      "Map vulnerabilities to your cluster version"
    ],
    "common_use_cases": [
      "Kubernetes cluster vulnerability assessment",
      "Security patch management planning",
      "Compliance reporting for container platforms",
      "Incident response for Kubernetes security issues",
      "Risk assessment for Kubernetes upgrades",
      "Security awareness for DevOps teams",
      "Container security posture monitoring"
    ],
    "recommended_update_frequency": "Monitor daily for critical vulnerabilities, weekly for general security updates",
    "value_proposition": "Official Kubernetes security vulnerability data completely free via multiple channels"
  },
  "quality_metrics": {
    "accessibility": "No registration required",
    "api_stability": "Stable GitHub API",
    "completeness": "Comprehensive Kubernetes vulnerability coverage",
    "cost": "COMPLETELY FREE",
    "data_quality": "Official Kubernetes security team disclosures",
    "reliability": "excellent",
    "update_speed": "Real-time"
  },
  "quality_score": 95,
  "subcategory": "kubernetes",
  "url": "https://kubernetes.io/docs/reference/issues-security/"
}
