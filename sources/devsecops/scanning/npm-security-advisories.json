{
  "api": {
    "base_url": "https://registry.npmjs.org",
    "cli_access": {
      "commands": [
        "npm audit - Run security audit on current project",
        "npm audit --json - Get audit results in JSON format",
        "npm audit fix - Automatically fix vulnerabilities",
        "npm audit signatures - Verify package signatures",
        "npm audit --audit-level=moderate - Set severity threshold"
      ],
      "tool": "npm"
    },
    "endpoints": [
      {
        "description": "Submit package-lock.json for vulnerability audit",
        "method": "POST",
        "parameters": [
          {
            "description": "NPM package lock file content",
            "example": "{\"name\": \"my-app\", \"dependencies\": {...}}",
            "name": "package-lock.json",
            "required": true,
            "type": "object"
          }
        ],
        "path": "/-/npm/v1/security/audits",
        "response_format": "JSON audit report with vulnerabilities"
      },
      {
        "description": "Get bulk security advisory information",
        "method": "POST",
        "parameters": [
          {
            "description": "Package names and version ranges to check",
            "name": "body",
            "required": true,
            "type": "object"
          }
        ],
        "path": "/-/npm/v1/security/advisories/bulk"
      },
      {
        "description": "Get package metadata including security information",
        "method": "GET",
        "parameters": [
          {
            "description": "NPM package name",
            "example": "lodash",
            "name": "package_name",
            "required": true,
            "type": "string"
          }
        ],
        "path": "/{package_name}"
      }
    ],
    "github_integration": {
      "access": "free",
      "description": "npm advisories sourced from GitHub Security Advisory Database",
      "source": "GitHub Security Advisories",
      "url": "https://github.com/advisories"
    },
    "rate_limit": {
      "notes": "No documented rate limits for npm audit API",
      "requests_per_second": null
    },
    "type": "REST"
  },
  "authentication": {
    "notes": "COMPLETELY FREE! npm audit and security advisories accessible without authentication. No registration or API keys required.",
    "required": false,
    "type": "none"
  },
  "authority": 97,
  "category": "devsecops",
  "coverage": 94,
  "data_coverage": {
    "content_types": [
      "Node.js package vulnerabilities",
      "JavaScript library security issues",
      "CVSS severity scores",
      "Vulnerable version ranges",
      "Patched version information",
      "Dependency path analysis",
      "Exploit availability information",
      "Remediation recommendations"
    ],
    "package_ecosystems": [
      "npm packages",
      "Node.js modules",
      "JavaScript libraries",
      "TypeScript packages",
      "React/Vue/Angular packages",
      "Express.js modules",
      "Webpack plugins",
      "Babel plugins"
    ],
    "temporal": {
      "historical_data": "2018-present (structured advisories)",
      "latency": "Immediate integration with GitHub Security Advisories",
      "update_frequency": "Real-time updates as vulnerabilities are disclosed"
    },
    "vulnerability_types": [
      "Cross-Site Scripting (XSS)",
      "Code Injection",
      "Prototype Pollution",
      "Regular Expression DoS (ReDoS)",
      "Path Traversal",
      "Insecure Randomness",
      "Cryptographic Issues",
      "Denial of Service (DoS)"
    ]
  },
  "description": "npm Security Advisories database providing COMPLETELY FREE access to Node.js and JavaScript package vulnerabilities through npm audit API, CLI tools, and GitHub Security Advisories integration.",
  "documentation": "https://docs.npmjs.com/cli/v10/commands/npm-audit",
  "format": "json",
  "id": "npm-security-advisories",
  "integration_examples": {
    "cli": {
      "advanced_audit": "# Advanced npm audit with custom configuration\n# Set severity threshold\nnpm audit --audit-level=moderate\n\n# Audit with specific package manager\nnpm audit --package-manager=npm\n\n# Get human-readable and JSON output\nnpm audit --json | tee audit-results.json | jq '.vulnerabilities'\n\n# Check signatures (npm 9+)\nnpm audit signatures\n\n# Audit production dependencies only\nnpm audit --omit=dev\n\n# Force audit even if package-lock.json is missing\nnpm audit --force",
      "basic_audit": "# Basic npm security audit - COMPLETELY FREE!\n# Navigate to your Node.js project directory\ncd /path/to/your/project\n\n# Run security audit\nnpm audit\n\n# Get detailed JSON output\nnpm audit --json > audit-report.json\n\n# Fix vulnerabilities automatically\nnpm audit fix\n\n# Fix only production dependencies\nnpm audit fix --only=prod\n\n# Show audit results without fixing\nnpm audit --dry-run"
    },
    "curl": {
      "bulk_package_info": "# Get multiple package info\nfor pkg in express react vue angular; do\n  echo \"=== $pkg ===\"\n  curl -s \"https://registry.npmjs.org/$pkg\" | jq '{name, \"latest-version\": .\"dist-tags\".latest, maintainers: .maintainers | length}'\ndone",
      "package_versions": "# Get all versions of a package\ncurl -s 'https://registry.npmjs.org/lodash' | jq '.versions | keys | length' && echo \" total versions\"",
      "recent_updates": "# Check recent package updates\ncurl -s 'https://registry.npmjs.org/express' | jq '.time | to_entries | sort_by(.value) | .[-5:] | .[] | {version: .key, date: .value}'",
      "registry_lookup": "# Look up npm package information - COMPLETELY FREE!\ncurl -s 'https://registry.npmjs.org/lodash' | jq '{name, description, \"dist-tags\": .\"dist-tags\", maintainers: .maintainers | length}'"
    },
    "github_actions": {
      "workflow": "# npm Security Audit GitHub Action - COMPLETELY FREE!\nname: npm Security Audit\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 2 * * *'  # Daily security check\n\njobs:\n  security-audit:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run npm security audit\n      run: |\n        echo \"\ud83d\udd0d Running npm security audit (FREE!)\"\n        npm audit --audit-level=moderate\n        \n    - name: Generate audit report\n      if: always()\n      run: |\n        npm audit --json > npm-audit-report.json\n        echo \"\ud83d\udcca Audit report generated\"\n        \n    - name: Check for critical vulnerabilities\n      run: |\n        CRITICAL=$(cat npm-audit-report.json | jq '.metadata.vulnerabilities.critical // 0')\n        HIGH=$(cat npm-audit-report.json | jq '.metadata.vulnerabilities.high // 0')\n        \n        echo \"Critical vulnerabilities: $CRITICAL\"\n        echo \"High vulnerabilities: $HIGH\"\n        \n        if [ \"$CRITICAL\" -gt \"0\" ] || [ \"$HIGH\" -gt \"0\" ]; then\n          echo \"\u274c Critical or high vulnerabilities found!\"\n          echo \"SECURITY_ISSUES=true\" >> $GITHUB_ENV\n          exit 1\n        else\n          echo \"\u2705 No critical or high vulnerabilities found\"\n          echo \"SECURITY_ISSUES=false\" >> $GITHUB_ENV\n        fi\n    \n    - name: Attempt automatic fix\n      if: failure()\n      run: |\n        echo \"\ud83d\udd27 Attempting to fix vulnerabilities automatically\"\n        npm audit fix --only=prod\n        \n        # Re-run audit after fix\n        npm audit --audit-level=moderate\n    \n    - name: Upload audit report\n      if: always()\n      uses: actions/upload-artifact@v4\n      with:\n        name: npm-audit-report\n        path: npm-audit-report.json\n        retention-days: 30\n    \n    - name: Comment PR with audit results\n      if: github.event_name == 'pull_request' && always()\n      uses: actions/github-script@v7\n      with:\n        script: |\n          const fs = require('fs');\n          const auditReport = JSON.parse(fs.readFileSync('npm-audit-report.json', 'utf8'));\n          \n          const metadata = auditReport.metadata || {};\n          const vulnerabilities = metadata.vulnerabilities || {};\n          \n          const totalVulns = (vulnerabilities.critical || 0) + \n                            (vulnerabilities.high || 0) + \n                            (vulnerabilities.moderate || 0) + \n                            (vulnerabilities.low || 0);\n          \n          let comment = `## \ud83d\udd0d npm Security Audit Results\\n\\n`;\n          comment += `**Total Vulnerabilities:** ${totalVulns}\\n\\n`;\n          \n          if (totalVulns > 0) {\n            comment += `| Severity | Count |\\n|----------|-------|\\n`;\n            comment += `| Critical | ${vulnerabilities.critical || 0} |\\n`;\n            comment += `| High | ${vulnerabilities.high || 0} |\\n`;\n            comment += `| Moderate | ${vulnerabilities.moderate || 0} |\\n`;\n            comment += `| Low | ${vulnerabilities.low || 0} |\\n\\n`;\n            \n            if ((vulnerabilities.critical || 0) > 0 || (vulnerabilities.high || 0) > 0) {\n              comment += `\u26a0\ufe0f **Action Required:** Critical or high severity vulnerabilities detected!\\n\\n`;\n              comment += `Run \\`npm audit fix\\` to attempt automatic remediation.`;\n            }\n          } else {\n            comment += `\u2705 **No vulnerabilities detected** - excellent security posture!`;\n          }\n          \n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: comment\n          });"
    },
    "nodejs": {
      "audit_script": "#!/usr/bin/env node\n// npm security audit automation script - COMPLETELY FREE!\n\nconst { execSync, spawn } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\nclass NPMSecurityAuditor {\n  constructor(projectPath = process.cwd()) {\n    this.projectPath = projectPath;\n    this.auditResults = null;\n  }\n  \n  checkNPMProject() {\n    const packageJsonPath = path.join(this.projectPath, 'package.json');\n    return fs.existsSync(packageJsonPath);\n  }\n  \n  async runAudit(options = {}) {\n    const {\n      auditLevel = 'moderate',\n      productionOnly = false,\n      autoFix = false,\n      outputFile = null\n    } = options;\n    \n    if (!this.checkNPMProject()) {\n      throw new Error('No package.json found. Not an npm project.');\n    }\n    \n    console.log('\ud83d\udd0d Running npm security audit (FREE!)...');\n    \n    try {\n      // Build audit command\n      const auditCmd = ['npm', 'audit', '--json'];\n      \n      if (auditLevel) {\n        auditCmd.push('--audit-level', auditLevel);\n      }\n      \n      if (productionOnly) {\n        auditCmd.push('--omit=dev');\n      }\n      \n      // Run audit\n      const auditOutput = execSync(auditCmd.join(' '), {\n        cwd: this.projectPath,\n        encoding: 'utf8',\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n      \n      this.auditResults = JSON.parse(auditOutput);\n      \n      // Save to file if requested\n      if (outputFile) {\n        fs.writeFileSync(outputFile, JSON.stringify(this.auditResults, null, 2));\n        console.log(`\ud83d\udcc4 Audit results saved to ${outputFile}`);\n      }\n      \n      // Attempt auto-fix if requested and vulnerabilities found\n      if (autoFix && this.hasVulnerabilities()) {\n        await this.fixVulnerabilities(productionOnly);\n      }\n      \n      return this.auditResults;\n      \n    } catch (error) {\n      // npm audit returns non-zero exit code when vulnerabilities are found\n      if (error.stdout) {\n        try {\n          this.auditResults = JSON.parse(error.stdout);\n          \n          if (autoFix && this.hasVulnerabilities()) {\n            await this.fixVulnerabilities(productionOnly);\n          }\n          \n          return this.auditResults;\n        } catch (parseError) {\n          throw new Error(`Failed to parse audit output: ${parseError.message}`);\n        }\n      } else {\n        throw new Error(`npm audit failed: ${error.message}`);\n      }\n    }\n  }\n  \n  hasVulnerabilities() {\n    if (!this.auditResults) return false;\n    \n    const metadata = this.auditResults.metadata || {};\n    const vulnerabilities = metadata.vulnerabilities || {};\n    \n    return Object.values(vulnerabilities).some(count => count > 0);\n  }\n  \n  async fixVulnerabilities(productionOnly = false) {\n    console.log('\ud83d\udd27 Attempting to fix vulnerabilities automatically...');\n    \n    try {\n      const fixCmd = ['npm', 'audit', 'fix'];\n      \n      if (productionOnly) {\n        fixCmd.push('--only=prod');\n      }\n      \n      const fixOutput = execSync(fixCmd.join(' '), {\n        cwd: this.projectPath,\n        encoding: 'utf8'\n      });\n      \n      console.log('\u2705 Vulnerabilities fixed:', fixOutput);\n      \n      // Re-run audit to get updated results\n      const updatedResults = await this.runAudit({ autoFix: false });\n      return updatedResults;\n      \n    } catch (error) {\n      console.log('\u26a0\ufe0f  Some vulnerabilities could not be auto-fixed:', error.message);\n      return false;\n    }\n  }\n  \n  generateReport() {\n    if (!this.auditResults) {\n      console.log('\u274c No audit results available');\n      return;\n    }\n    \n    const metadata = this.auditResults.metadata || {};\n    const vulnerabilities = metadata.vulnerabilities || {};\n    const totalVulns = Object.values(vulnerabilities).reduce((sum, count) => sum + count, 0);\n    \n    console.log('\\n\ud83d\udcca npm Security Audit Report (FREE!)\\n');\n    console.log('='.repeat(50));\n    console.log(`Project: ${path.basename(this.projectPath)}`);\n    console.log(`Scan Date: ${new Date().toISOString().slice(0, 19)}\\n`);\n    \n    console.log(`\ud83d\udce6 Total Vulnerabilities: ${totalVulns}`);\n    \n    if (totalVulns > 0) {\n      console.log('\\n\ud83d\udcc8 Severity Breakdown:');\n      \n      const severityIcons = {\n        critical: '\ud83d\udd34',\n        high: '\ud83d\udfe0',\n        moderate: '\ud83d\udfe1',\n        low: '\ud83d\udfe2',\n        info: '\ud83d\udd35'\n      };\n      \n      ['critical', 'high', 'moderate', 'low', 'info'].forEach(severity => {\n        const count = vulnerabilities[severity] || 0;\n        if (count > 0) {\n          const icon = severityIcons[severity] || '\u26aa';\n          console.log(`   ${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}`);\n        }\n      });\n      \n      // Show vulnerable packages\n      const vulnPackages = this.auditResults.vulnerabilities || {};\n      const packageNames = Object.keys(vulnPackages);\n      \n      if (packageNames.length > 0) {\n        console.log('\\n\u26a0\ufe0f  Vulnerable Packages:');\n        packageNames.slice(0, 10).forEach(pkg => {\n          const pkgInfo = vulnPackages[pkg];\n          if (pkgInfo && typeof pkgInfo === 'object') {\n            const severity = pkgInfo.severity || 'unknown';\n            const icon = severityIcons[severity] || '\u26aa';\n            console.log(`   ${icon} ${pkg} (${severity})`);\n          }\n        });\n        \n        if (packageNames.length > 10) {\n          console.log(`   ... and ${packageNames.length - 10} more packages`);\n        }\n      }\n      \n      console.log('\\n\ud83d\udca1 Recommendations:');\n      \n      const criticalCount = vulnerabilities.critical || 0;\n      const highCount = vulnerabilities.high || 0;\n      \n      if (criticalCount > 0) {\n        console.log(`   \ud83d\udea8 URGENT: Address ${criticalCount} critical vulnerabilities immediately`);\n      }\n      \n      if (highCount > 0) {\n        console.log(`   \u26a0\ufe0f  HIGH: Address ${highCount} high-severity vulnerabilities`);\n      }\n      \n      console.log('   \ud83d\udd27 Run \\'npm audit fix\\' to automatically resolve fixable issues');\n      console.log('   \ud83d\udccb Review remaining vulnerabilities manually');\n      console.log('   \ud83d\udd04 Keep dependencies updated regularly');\n      \n    } else {\n      console.log('\\n\u2705 No vulnerabilities detected - excellent security posture!');\n      console.log('\\n\ud83d\udca1 Recommendations:');\n      console.log('   \ud83d\udd04 Continue regular security audits');\n      console.log('   \ud83d\udce6 Keep dependencies updated');\n      console.log('   \ud83d\udd0d Monitor for new security advisories');\n    }\n    \n    return {\n      totalVulnerabilities: totalVulns,\n      severityDistribution: vulnerabilities,\n      hasHighSeverity: (vulnerabilities.critical || 0) > 0 || (vulnerabilities.high || 0) > 0\n    };\n  }\n}\n\n// CLI usage\nif (require.main === module) {\n  const auditor = new NPMSecurityAuditor();\n  \n  const options = {\n    auditLevel: process.argv.includes('--high') ? 'high' : 'moderate',\n    productionOnly: process.argv.includes('--prod'),\n    autoFix: process.argv.includes('--fix'),\n    outputFile: process.argv.includes('--output') ? 'npm-audit-report.json' : null\n  };\n  \n  auditor.runAudit(options)\n    .then(() => {\n      const report = auditor.generateReport();\n      \n      // Exit with error code if high severity vulnerabilities found\n      if (report && report.hasHighSeverity) {\n        console.log('\\n\u274c Exiting with error due to high/critical vulnerabilities');\n        process.exit(1);\n      } else {\n        console.log('\\n\u2705 Security audit passed');\n        process.exit(0);\n      }\n    })\n    .catch(error => {\n      console.error('\u274c Audit failed:', error.message);\n      process.exit(1);\n    });\n}\n\nmodule.exports = NPMSecurityAuditor;"
    },
    "python": {
      "npm_audit_automation": "import subprocess\nimport json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass NPMAuditScanner:\n    \"\"\"npm security audit automation - COMPLETELY FREE!\"\"\"\n    \n    def __init__(self, project_path='.'):\n        self.project_path = Path(project_path)\n        self.audit_results = None\n    \n    def check_npm_project(self):\n        \"\"\"Check if current directory is a valid npm project\"\"\"\n        package_json = self.project_path / 'package.json'\n        return package_json.exists()\n    \n    def run_audit(self, audit_level='moderate', fix_vulnerabilities=False):\n        \"\"\"Run npm audit on the project\"\"\"\n        if not self.check_npm_project():\n            print(\"\u274c No package.json found. Not an npm project.\")\n            return False\n        \n        print(f\"\ud83d\udd0d Running npm audit (FREE!) on {self.project_path}...\")\n        \n        # Build audit command\n        cmd = ['npm', 'audit', '--json']\n        \n        if audit_level:\n            cmd.extend(['--audit-level', audit_level])\n        \n        try:\n            # Run audit\n            result = subprocess.run(\n                cmd,\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=300  # 5 minutes\n            )\n            \n            # Parse JSON output\n            if result.stdout:\n                try:\n                    self.audit_results = json.loads(result.stdout)\n                    print(f\"\u2705 Audit completed with exit code: {result.returncode}\")\n                    \n                    if fix_vulnerabilities and result.returncode != 0:\n                        return self.fix_vulnerabilities()\n                    \n                    return True\n                    \n                except json.JSONDecodeError as e:\n                    print(f\"\u274c Failed to parse audit results: {e}\")\n                    print(f\"Raw output: {result.stdout[:500]}\")\n                    return False\n            else:\n                print(f\"\u26a0\ufe0f  No audit output received. Exit code: {result.returncode}\")\n                if result.stderr:\n                    print(f\"Error: {result.stderr}\")\n                return False\n                \n        except subprocess.TimeoutExpired:\n            print(\"\u274c npm audit timed out\")\n            return False\n        except FileNotFoundError:\n            print(\"\u274c npm not found. Please install Node.js and npm\")\n            return False\n        except Exception as e:\n            print(f\"\u274c Audit failed: {e}\")\n            return False\n    \n    def fix_vulnerabilities(self, prod_only=False):\n        \"\"\"Attempt to fix vulnerabilities automatically\"\"\"\n        print(\"\ud83d\udd27 Attempting to fix vulnerabilities...\")\n        \n        cmd = ['npm', 'audit', 'fix']\n        \n        if prod_only:\n            cmd.append('--only=prod')\n        \n        try:\n            result = subprocess.run(\n                cmd,\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=600  # 10 minutes for fixes\n            )\n            \n            if result.returncode == 0:\n                print(\"\u2705 Vulnerabilities fixed successfully\")\n                print(result.stdout)\n                return True\n            else:\n                print(f\"\u26a0\ufe0f  Some vulnerabilities could not be auto-fixed\")\n                print(result.stdout)\n                return False\n                \n        except Exception as e:\n            print(f\"\u274c Fix attempt failed: {e}\")\n            return False\n    \n    def analyze_audit_results(self):\n        \"\"\"Analyze audit results and generate summary\"\"\"\n        if not self.audit_results:\n            return None\n        \n        analysis = {\n            'total_vulnerabilities': 0,\n            'severity_distribution': {},\n            'vulnerable_packages': {},\n            'fix_available': 0,\n            'manual_review_required': 0,\n            'scan_date': datetime.now().isoformat()\n        }\n        \n        # Extract vulnerability information\n        vulnerabilities = self.audit_results.get('vulnerabilities', {})\n        \n        for package_name, vuln_info in vulnerabilities.items():\n            if isinstance(vuln_info, dict):\n                severity = vuln_info.get('severity', 'unknown')\n                \n                # Count by severity\n                analysis['severity_distribution'][severity] = \\\n                    analysis['severity_distribution'].get(severity, 0) + 1\n                \n                analysis['total_vulnerabilities'] += 1\n                \n                # Track vulnerable packages\n                analysis['vulnerable_packages'][package_name] = {\n                    'severity': severity,\n                    'via': vuln_info.get('via', []),\n                    'effects': vuln_info.get('effects', []),\n                    'range': vuln_info.get('range', 'unknown'),\n                    'fix_available': vuln_info.get('fixAvailable', False)\n                }\n                \n                # Count fix availability\n                if vuln_info.get('fixAvailable'):\n                    if isinstance(vuln_info['fixAvailable'], bool) and vuln_info['fixAvailable']:\n                        analysis['fix_available'] += 1\n                    elif isinstance(vuln_info['fixAvailable'], dict):\n                        analysis['fix_available'] += 1\n                else:\n                    analysis['manual_review_required'] += 1\n        \n        return analysis\n    \n    def generate_security_report(self):\n        \"\"\"Generate human-readable security report\"\"\"\n        if not self.audit_results:\n            print(\"\u274c No audit results available\")\n            return\n        \n        analysis = self.analyze_audit_results()\n        \n        print(f\"\\n\ud83d\udcca npm Security Audit Report (FREE!)\\n\")\n        print(f\"Project Path: {self.project_path}\")\n        print(f\"Scan Date: {analysis['scan_date'][:19]}\\n\")\n        \n        # Overall statistics\n        print(f\"\ud83d\udce6 Total Vulnerabilities: {analysis['total_vulnerabilities']}\")\n        print(f\"\ud83d\udd27 Automatically Fixable: {analysis['fix_available']}\")\n        print(f\"\ud83d\udc41\ufe0f  Manual Review Required: {analysis['manual_review_required']}\\n\")\n        \n        # Severity distribution\n        if analysis['severity_distribution']:\n            print(\"\ud83d\udcc8 Severity Distribution:\")\n            severity_order = ['critical', 'high', 'moderate', 'low', 'info']\n            \n            for severity in severity_order:\n                count = analysis['severity_distribution'].get(severity, 0)\n                if count > 0:\n                    severity_icon = {\n                        'critical': '\ud83d\udd34',\n                        'high': '\ud83d\udfe0',\n                        'moderate': '\ud83d\udfe1',\n                        'low': '\ud83d\udfe2',\n                        'info': '\ud83d\udd35'\n                    }.get(severity, '\u26aa')\n                    \n                    print(f\"   {severity_icon} {severity.title()}: {count}\")\n            print()\n        \n        # Vulnerable packages details\n        if analysis['vulnerable_packages']:\n            print(\"\u26a0\ufe0f  Vulnerable Packages:\")\n            \n            # Sort by severity\n            severity_priority = {'critical': 4, 'high': 3, 'moderate': 2, 'low': 1, 'info': 0}\n            \n            sorted_packages = sorted(\n                analysis['vulnerable_packages'].items(),\n                key=lambda x: severity_priority.get(x[1]['severity'], 0),\n                reverse=True\n            )\n            \n            for package_name, details in sorted_packages[:10]:  # Show top 10\n                severity_icon = {\n                    'critical': '\ud83d\udd34',\n                    'high': '\ud83d\udfe0',\n                    'moderate': '\ud83d\udfe1',\n                    'low': '\ud83d\udfe2',\n                    'info': '\ud83d\udd35'\n                }.get(details['severity'], '\u26aa')\n                \n                print(f\"   {severity_icon} {package_name}\")\n                print(f\"      Severity: {details['severity'].title()}\")\n                print(f\"      Range: {details['range']}\")\n                \n                if details['fix_available']:\n                    print(f\"      \ud83d\udd27 Fix available\")\n                else:\n                    print(f\"      \ud83d\udc41\ufe0f  Manual review required\")\n                \n                if details['effects']:\n                    effects_str = ', '.join(details['effects'][:3])\n                    print(f\"      Affects: {effects_str}\")\n                \n                print()\n        \n        # Recommendations\n        print(\"\ud83d\udca1 Recommendations:\")\n        \n        critical_count = analysis['severity_distribution'].get('critical', 0)\n        high_count = analysis['severity_distribution'].get('high', 0)\n        \n        if critical_count > 0:\n            print(f\"   \ud83d\udea8 URGENT: Address {critical_count} critical vulnerabilities immediately\")\n        \n        if high_count > 0:\n            print(f\"   \u26a0\ufe0f  HIGH: Address {high_count} high-severity vulnerabilities\")\n        \n        if analysis['fix_available'] > 0:\n            print(f\"   \ud83d\udd27 Run 'npm audit fix' to automatically resolve {analysis['fix_available']} vulnerabilities\")\n        \n        if analysis['manual_review_required'] > 0:\n            print(f\"   \ud83d\udc41\ufe0f  Manually review {analysis['manual_review_required']} vulnerabilities that require attention\")\n        \n        if analysis['total_vulnerabilities'] == 0:\n            print(\"   \u2705 No vulnerabilities detected - excellent security posture!\")\n        \n        return analysis\n    \n    def run_complete_audit(self, audit_level='moderate', auto_fix=False):\n        \"\"\"Run complete audit workflow\"\"\"\n        success = self.run_audit(audit_level, auto_fix)\n        \n        if success:\n            return self.generate_security_report()\n        \n        return None\n\n# Usage examples\nif __name__ == \"__main__\":\n    # Scan current directory\n    scanner = NPMAuditScanner()\n    analysis = scanner.run_complete_audit()\n    \n    # Scan specific project\n    # scanner = NPMAuditScanner('/path/to/node/project')\n    # analysis = scanner.run_complete_audit(audit_level='high', auto_fix=True)\n    \n    # Check results for CI/CD\n    if analysis:\n        critical_vulns = analysis['severity_distribution'].get('critical', 0)\n        high_vulns = analysis['severity_distribution'].get('high', 0)\n        \n        if critical_vulns > 0 or high_vulns > 0:\n            print(f\"\\n\u274c Build should FAIL: {critical_vulns + high_vulns} critical/high vulnerabilities\")\n            exit(1)\n        else:\n            print(\"\\n\u2705 Build can proceed: No critical/high vulnerabilities\")\n            exit(0)",
      "package_scanner": "import requests\nimport json\nimport asyncio\nimport aiohttp\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\n\nclass NPMPackageSecurityChecker:\n    \"\"\"Check individual npm packages for security issues - COMPLETELY FREE!\"\"\"\n    \n    def __init__(self):\n        self.registry_url = 'https://registry.npmjs.org'\n        self.results = {}\n    \n    async def check_package_security(self, session: aiohttp.ClientSession, \n                                   package_name: str, version: Optional[str] = None) -> Dict:\n        \"\"\"Check a single package for security information\"\"\"\n        try:\n            # Get package metadata\n            package_url = f'{self.registry_url}/{package_name}'\n            \n            async with session.get(package_url) as response:\n                if response.status == 200:\n                    package_data = await response.json()\n                    \n                    security_info = {\n                        'package': package_name,\n                        'version': version or package_data.get('dist-tags', {}).get('latest', 'unknown'),\n                        'last_modified': package_data.get('time', {}).get('modified', 'unknown'),\n                        'maintainers': len(package_data.get('maintainers', [])),\n                        'has_vulnerabilities': False,\n                        'security_advisories': [],\n                        'audit_info': None\n                    }\n                    \n                    # Check for security-related keywords in description\n                    description = package_data.get('description', '').lower()\n                    security_keywords = ['security', 'vulnerability', 'exploit', 'patch']\n                    \n                    if any(keyword in description for keyword in security_keywords):\n                        security_info['security_related'] = True\n                    \n                    # Get versions for vulnerability checking\n                    versions = package_data.get('versions', {})\n                    security_info['total_versions'] = len(versions)\n                    \n                    return security_info\n                    \n                else:\n                    return {\n                        'package': package_name,\n                        'error': f'HTTP {response.status}',\n                        'version': version\n                    }\n                    \n        except Exception as e:\n            return {\n                'package': package_name,\n                'error': str(e),\n                'version': version\n            }\n    \n    async def bulk_audit_packages(self, packages: List[str]) -> Dict:\n        \"\"\"Audit multiple packages concurrently\"\"\"\n        print(f\"\ud83d\udd0d Auditing {len(packages)} npm packages (FREE!)...\")\n        \n        async with aiohttp.ClientSession() as session:\n            tasks = [\n                self.check_package_security(session, pkg) \n                for pkg in packages\n            ]\n            \n            results = await asyncio.gather(*tasks, return_exceptions=True)\n            \n            audit_summary = {\n                'total_packages': len(packages),\n                'successful_checks': 0,\n                'failed_checks': 0,\n                'packages': {},\n                'scan_date': datetime.now().isoformat()\n            }\n            \n            for result in results:\n                if isinstance(result, dict) and 'error' not in result:\n                    audit_summary['successful_checks'] += 1\n                    audit_summary['packages'][result['package']] = result\n                else:\n                    audit_summary['failed_checks'] += 1\n                    if isinstance(result, dict):\n                        audit_summary['packages'][result['package']] = result\n            \n            return audit_summary\n    \n    def analyze_package_ecosystem(self, package_list_file: str) -> Dict:\n        \"\"\"Analyze a list of packages from a file\"\"\"\n        try:\n            with open(package_list_file, 'r') as f:\n                if package_list_file.endswith('.json'):\n                    # Assume package.json format\n                    data = json.load(f)\n                    packages = list(data.get('dependencies', {}).keys()) + \\\n                              list(data.get('devDependencies', {}).keys())\n                else:\n                    # Assume plain text, one package per line\n                    packages = [line.strip() for line in f if line.strip()]\n            \n            # Run async audit\n            loop = asyncio.get_event_loop()\n            return loop.run_until_complete(self.bulk_audit_packages(packages))\n            \n        except Exception as e:\n            print(f\"\u274c Error analyzing package ecosystem: {e}\")\n            return {}\n    \n    def generate_ecosystem_report(self, audit_results: Dict):\n        \"\"\"Generate comprehensive ecosystem security report\"\"\"\n        if not audit_results:\n            return\n        \n        print(f\"\\n\ud83d\udcca npm Ecosystem Security Report (FREE!)\\n\")\n        print(f\"Scan Date: {audit_results['scan_date'][:19]}\")\n        print(f\"Total Packages: {audit_results['total_packages']}\")\n        print(f\"Successfully Analyzed: {audit_results['successful_checks']}\")\n        print(f\"Failed to Analyze: {audit_results['failed_checks']}\\n\")\n        \n        packages = audit_results.get('packages', {})\n        \n        # Package statistics\n        maintainer_counts = []\n        version_counts = []\n        recent_updates = []\n        \n        for pkg_name, pkg_info in packages.items():\n            if 'error' not in pkg_info:\n                maintainer_counts.append(pkg_info.get('maintainers', 0))\n                version_counts.append(pkg_info.get('total_versions', 0))\n                \n                # Check last modified date\n                last_modified = pkg_info.get('last_modified', '')\n                if last_modified and last_modified != 'unknown':\n                    try:\n                        # Simple date parsing for recent updates\n                        if '2024' in last_modified or '2025' in last_modified:\n                            recent_updates.append(pkg_name)\n                    except:\n                        pass\n        \n        if maintainer_counts:\n            avg_maintainers = sum(maintainer_counts) / len(maintainer_counts)\n            print(f\"\ud83d\udcca Package Statistics:\")\n            print(f\"   Average Maintainers per Package: {avg_maintainers:.1f}\")\n            print(f\"   Recently Updated Packages: {len(recent_updates)}\")\n            \n            if version_counts:\n                avg_versions = sum(version_counts) / len(version_counts)\n                print(f\"   Average Versions per Package: {avg_versions:.1f}\")\n            print()\n        \n        # Security indicators\n        security_related = []\n        low_maintenance = []\n        \n        for pkg_name, pkg_info in packages.items():\n            if 'error' not in pkg_info:\n                if pkg_info.get('security_related'):\n                    security_related.append(pkg_name)\n                \n                if pkg_info.get('maintainers', 0) <= 1:\n                    low_maintenance.append(pkg_name)\n        \n        if security_related:\n            print(f\"\ud83d\udd12 Security-Related Packages ({len(security_related)}):\")\n            for pkg in security_related[:5]:\n                print(f\"   \ud83d\udce6 {pkg}\")\n            if len(security_related) > 5:\n                print(f\"   ... and {len(security_related) - 5} more\")\n            print()\n        \n        if low_maintenance:\n            print(f\"\u26a0\ufe0f  Low-Maintenance Packages ({len(low_maintenance)}):\")\n            for pkg in low_maintenance[:5]:\n                print(f\"   \ud83d\udce6 {pkg} (\u22641 maintainer)\")\n            if len(low_maintenance) > 5:\n                print(f\"   ... and {len(low_maintenance) - 5} more\")\n            print()\n        \n        # Recommendations\n        print(\"\ud83d\udca1 Ecosystem Security Recommendations:\")\n        print(\"   \ud83d\udd0d Run 'npm audit' for detailed vulnerability scanning\")\n        print(\"   \ud83d\udcca Monitor low-maintenance packages for security updates\")\n        print(\"   \ud83d\udd04 Keep packages updated to latest secure versions\")\n        print(\"   \ud83d\udccb Review security-related packages for best practices\")\n        \n        if recent_updates:\n            print(f\"   \u2705 {len(recent_updates)} packages have recent updates - good maintenance\")\n        \n        return audit_results\n\n# Usage examples\nif __name__ == \"__main__\":\n    checker = NPMPackageSecurityChecker()\n    \n    # Check specific packages\n    packages_to_check = [\n        'express', 'lodash', 'react', 'axios', 'moment',\n        'jquery', 'webpack', 'babel-core', 'eslint'\n    ]\n    \n    # Run async audit\n    loop = asyncio.get_event_loop()\n    results = loop.run_until_complete(checker.bulk_audit_packages(packages_to_check))\n    \n    # Generate report\n    checker.generate_ecosystem_report(results)\n    \n    # Analyze package.json file\n    # results = checker.analyze_package_ecosystem('./package.json')\n    # checker.generate_ecosystem_report(results)"
    }
  },
  "last_updated": "2025-08-16T00:05:00.000Z",
  "metadata": {
    "alternatives": [
      "yarn-audit",
      "pnpm-audit",
      "snyk-vulnerability-scanner"
    ],
    "last_verified": "2025-08-16",
    "license": "Public API - Free access",
    "maintainer": "npm Inc. (GitHub)",
    "related_resources": [
      "GitHub Security Advisories",
      "Node.js Security Working Group",
      "npm Security Best Practices",
      "JavaScript Security Guidelines"
    ]
  },
  "name": "npm Security Advisories",
  "operational_guidance": {
    "best_practices": [
      "Run npm audit on every build and before deployments",
      "Integrate npm audit into CI/CD pipelines",
      "Use npm audit fix for automated remediation",
      "Monitor npm audit results in package.json changes",
      "Set appropriate audit-level thresholds for builds",
      "Review dependency trees for vulnerability impact"
    ],
    "common_use_cases": [
      "Node.js application security scanning",
      "JavaScript dependency vulnerability assessment",
      "DevSecOps pipeline integration",
      "Open source risk management",
      "Compliance auditing for Node.js projects",
      "Developer security awareness",
      "Automated security testing"
    ],
    "recommended_update_frequency": "Run on every npm install/update, integrate into CI/CD for continuous monitoring",
    "value_proposition": "Built-in Node.js security scanning with zero setup cost and comprehensive ecosystem coverage"
  },
  "quality_metrics": {
    "accessibility": "No authentication or registration required",
    "completeness": "Comprehensive Node.js ecosystem coverage",
    "cost": "COMPLETELY FREE",
    "data_quality": "High-quality data from GitHub Security Advisory Database and npm security team",
    "reliability": "excellent",
    "tool_stability": "Stable npm CLI integration",
    "update_speed": "Real-time updates from security researchers and maintainers"
  },
  "quality_score": 95,
  "subcategory": "scanning",
  "url": "https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities"
}
